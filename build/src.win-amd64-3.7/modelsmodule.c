/* File: modelsmodule.c
 * This file is auto-generated with f2py (version:2).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: Fri Oct 23 20:07:19 2020
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include "Python.h"
#include <stdarg.h>
#include "fortranobject.h"
#include <string.h>
#include <math.h>

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *models_error;
static PyObject *models_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
typedef char * string;

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
#define PRINTPYOBJERR(obj)\
    fprintf(stderr,"models.error is related to ");\
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");

#define pyobj_from_float1(v) (PyFloat_FromDouble(v))
\
#define FAILNULL(p) do {                                            \
    if ((p) == NULL) {                                              \
        PyErr_SetString(PyExc_MemoryError, "NULL pointer found");   \
        goto capi_fail;                                             \
    }                                                               \
} while (0)

#define STRINGMALLOC(str,len)\
    if ((str = (string)malloc(sizeof(char)*(len+1))) == NULL) {\
        PyErr_SetString(PyExc_MemoryError, "out of memory");\
        goto capi_fail;\
    } else {\
        (str)[len] = '\0';\
    }

#define rank(var) var ## _Rank
#define shape(var,dim) var ## _Dims[dim]
#define old_rank(var) (PyArray_NDIM((PyArrayObject *)(capi_ ## var ## _tmp)))
#define old_shape(var,dim) PyArray_DIM(((PyArrayObject *)(capi_ ## var ## _tmp)),dim)
#define fshape(var,dim) shape(var,rank(var)-dim-1)
#define len(var) shape(var,0)
#define flen(var) fshape(var,0)
#define old_size(var) PyArray_SIZE((PyArrayObject *)(capi_ ## var ## _tmp))
/* #define index(i) capi_i ## i */
#define slen(var) capi_ ## var ## _len
#define size(var, ...) f2py_size((PyArrayObject *)(capi_ ## var ## _tmp), ## __VA_ARGS__, -1)

#define STRINGFREE(str) do {if (!(str == NULL)) free(str);} while (0)

#define CHECKSCALAR(check,tcheck,name,show,var)\
    if (!(check)) {\
        char errstring[256];\
        sprintf(errstring, "%s: "show, "("tcheck") failed for "name, var);\
        PyErr_SetString(models_error,errstring);\
        /*goto capi_fail;*/\
    } else 
#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif

#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif

#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif

/* New SciPy */
#define TRYPYARRAYTEMPLATECHAR case NPY_STRING: *(char *)(PyArray_DATA(arr))=*v; break;
#define TRYPYARRAYTEMPLATELONG case NPY_LONG: *(long *)(PyArray_DATA(arr))=*v; break;
#define TRYPYARRAYTEMPLATEOBJECT case NPY_OBJECT: PyArray_SETITEM(arr,PyArray_DATA(arr),pyobj_from_ ## ctype ## 1(*v)); break;

#define TRYPYARRAYTEMPLATE(ctype,typecode) \
        PyArrayObject *arr = NULL;\
        if (!obj) return -2;\
        if (!PyArray_Check(obj)) return -1;\
        if (!(arr=(PyArrayObject *)obj)) {fprintf(stderr,"TRYPYARRAYTEMPLATE:");PRINTPYOBJERR(obj);return 0;}\
        if (PyArray_DESCR(arr)->type==typecode)  {*(ctype *)(PyArray_DATA(arr))=*v; return 1;}\
        switch (PyArray_TYPE(arr)) {\
                case NPY_DOUBLE: *(double *)(PyArray_DATA(arr))=*v; break;\
                case NPY_INT: *(int *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONG: *(long *)(PyArray_DATA(arr))=*v; break;\
                case NPY_FLOAT: *(float *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CDOUBLE: *(double *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CFLOAT: *(float *)(PyArray_DATA(arr))=*v; break;\
                case NPY_BOOL: *(npy_bool *)(PyArray_DATA(arr))=(*v!=0); break;\
                case NPY_UBYTE: *(unsigned char *)(PyArray_DATA(arr))=*v; break;\
                case NPY_BYTE: *(signed char *)(PyArray_DATA(arr))=*v; break;\
                case NPY_SHORT: *(short *)(PyArray_DATA(arr))=*v; break;\
                case NPY_USHORT: *(npy_ushort *)(PyArray_DATA(arr))=*v; break;\
                case NPY_UINT: *(npy_uint *)(PyArray_DATA(arr))=*v; break;\
                case NPY_ULONG: *(npy_ulong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONGLONG: *(npy_longlong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_ULONGLONG: *(npy_ulonglong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CLONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=*v; break;\
                case NPY_OBJECT: PyArray_SETITEM(arr, PyArray_DATA(arr), pyobj_from_ ## ctype ## 1(*v)); break;\
        default: return -2;\
        };\
        return 1

#define STRINGCOPYN(to,from,buf_size)                           \
    do {                                                        \
        int _m = (buf_size);                                    \
        char *_to = (to);                                       \
        char *_from = (from);                                   \
        FAILNULL(_to); FAILNULL(_from);                         \
        (void)strncpy(_to, _from, sizeof(char)*_m);             \
        _to[_m-1] = '\0';                                      \
        /* Padding with spaces instead of nulls */              \
        for (_m -= 2; _m >= 0 && _to[_m] == '\0'; _m--) {      \
            _to[_m] = ' ';                                      \
        }                                                       \
    } while (0)


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
static int double_from_pyobj(double* v,PyObject *obj,const char *errmess) {
    PyObject* tmp = NULL;
    if (PyFloat_Check(obj)) {
#ifdef __sgi
        *v = PyFloat_AsDouble(obj);
#else
        *v = PyFloat_AS_DOUBLE(obj);
#endif
        return 1;
    }
    tmp = PyNumber_Float(obj);
    if (tmp) {
#ifdef __sgi
        *v = PyFloat_AsDouble(tmp);
#else
        *v = PyFloat_AS_DOUBLE(tmp);
#endif
        Py_DECREF(tmp);
        return 1;
    }
    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyString_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj,0);
    if (tmp) {
        PyErr_Clear();
        if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = models_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int f2py_size(PyArrayObject* var, ...)
{
  npy_int sz = 0;
  npy_int dim;
  npy_int rank;
  va_list argp;
  va_start(argp, var);
  dim = va_arg(argp, npy_int);
  if (dim==-1)
    {
      sz = PyArray_SIZE(var);
    }
  else
    {
      rank = PyArray_NDIM(var);
      if (dim>=1 && dim<=rank)
        sz = PyArray_DIM(var, dim-1);
      else
        fprintf(stderr, "f2py_size: 2nd argument value=%d fails to satisfy 1<=value<=%d. Result will be 0.\n", dim, rank);
    }
  va_end(argp);
  return sz;
}

static int int_from_pyobj(int* v,PyObject *obj,const char *errmess) {
    PyObject* tmp = NULL;
    if (PyInt_Check(obj)) {
        *v = (int)PyInt_AS_LONG(obj);
        return 1;
    }
    tmp = PyNumber_Int(obj);
    if (tmp) {
        *v = PyInt_AS_LONG(tmp);
        Py_DECREF(tmp);
        return 1;
    }
    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyString_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj,0);
    if (tmp) {
        PyErr_Clear();
        if (int_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = models_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int string_from_pyobj(string *str,int *len,const string inistr,PyObject *obj,const char *errmess) {
    PyArrayObject *arr = NULL;
    PyObject *tmp = NULL;
#ifdef DEBUGCFUNCS
fprintf(stderr,"string_from_pyobj(str='%s',len=%d,inistr='%s',obj=%p)\n",(char*)str,*len,(char *)inistr,obj);
#endif
    if (obj == Py_None) {
        if (*len == -1)
            *len = strlen(inistr); /* Will this cause problems? */
        STRINGMALLOC(*str,*len);
        STRINGCOPYN(*str,inistr,*len+1);
        return 1;
    }
    if (PyArray_Check(obj)) {
        if ((arr = (PyArrayObject *)obj) == NULL)
            goto capi_fail;
        if (!ISCONTIGUOUS(arr)) {
            PyErr_SetString(PyExc_ValueError,"array object is non-contiguous.");
            goto capi_fail;
        }
        if (*len == -1)
            *len = (PyArray_ITEMSIZE(arr))*PyArray_SIZE(arr);
        STRINGMALLOC(*str,*len);
        STRINGCOPYN(*str,PyArray_DATA(arr),*len+1);
        return 1;
    }
    if (PyString_Check(obj)) {
        tmp = obj;
        Py_INCREF(tmp);
    }
#if PY_VERSION_HEX >= 0x03000000
    else if (PyUnicode_Check(obj)) {
        tmp = PyUnicode_AsASCIIString(obj);
    }
    else {
        PyObject *tmp2;
        tmp2 = PyObject_Str(obj);
        if (tmp2) {
            tmp = PyUnicode_AsASCIIString(tmp2);
            Py_DECREF(tmp2);
        }
        else {
            tmp = NULL;
        }
    }
#else
    else {
        tmp = PyObject_Str(obj);
    }
#endif
    if (tmp == NULL) goto capi_fail;
    if (*len == -1)
        *len = PyString_GET_SIZE(tmp);
    STRINGMALLOC(*str,*len);
    STRINGCOPYN(*str,PyString_AS_STRING(tmp),*len+1);
    Py_DECREF(tmp);
    return 1;
capi_fail:
    Py_XDECREF(tmp);
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = models_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int float_from_pyobj(float* v,PyObject *obj,const char *errmess) {
    double d=0.0;
    if (double_from_pyobj(&d,obj,errmess)) {
        *v = (float)d;
        return 1;
    }
    return 0;
}

static int try_pyarr_from_float(PyObject* obj,float* v) {
    TRYPYARRAYTEMPLATE(float,'f');
}


/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/********************************** shia_v1 **********************************/
static char doc_f2py_rout_models_models_shia_v1[] = "\
q,qsed,qseparated,hum,st1,st3,balance,speed,areacontrol,stoout,qsep_byrain = shia_v1(ruta_bin,ruta_hdr,calib,n_cont,n_conth,n_reg,[stoin,hspeedin,n_cel,ruta_storage,ruta_speed,ruta_vfluxes,ruta_binconv,ruta_binstra,ruta_hdrconv,ruta_hdrstra,ruta_retorno,ruta_rc])\n\nWrapper for ``shia_v1``.\
\n\nParameters\n----------\n"
"ruta_bin : input string(len=500)\n"
"ruta_hdr : input string(len=500)\n"
"calib : input rank-1 array('f') with bounds (11)\n"
"n_cont : input int\n"
"n_conth : input int\n"
"n_reg : input int\n"
"\nOther Parameters\n----------------\n"
"stoin : input rank-2 array('f') with bounds (5,n_cel)\n"
"hspeedin : input rank-2 array('f') with bounds (4,n_cel)\n"
"n_cel : input int, optional\n    Default: shape(stoin,1)\n"
"ruta_storage : input string(len=500)\n"
"ruta_speed : input string(len=500)\n"
"ruta_vfluxes : input string(len=500)\n"
"ruta_binconv : input string(len=500)\n"
"ruta_binstra : input string(len=500)\n"
"ruta_hdrconv : input string(len=500)\n"
"ruta_hdrstra : input string(len=500)\n"
"ruta_retorno : input string(len=500)\n"
"ruta_rc : input string(len=500)\n"
"\nReturns\n-------\n"
"q : rank-2 array('f') with bounds (n_cont,n_reg)\n"
"qsed : rank-3 array('f') with bounds (n_cont,3,n_reg)\n"
"qseparated : rank-3 array('f') with bounds (n_cont,3,n_reg)\n"
"hum : rank-2 array('f') with bounds (n_conth,n_reg)\n"
"st1 : rank-2 array('f') with bounds (n_conth,n_reg)\n"
"st3 : rank-2 array('f') with bounds (n_conth,n_reg)\n"
"balance : rank-1 array('f') with bounds (n_reg)\n"
"speed : rank-2 array('f') with bounds (n_cont,n_reg)\n"
"areacontrol : rank-2 array('f') with bounds (n_cont,n_reg)\n"
"stoout : rank-2 array('f') with bounds (5,n_cel)\n"
"qsep_byrain : rank-3 array('f') with bounds (n_cont,2,n_reg)";
/*  */
static PyObject *f2py_rout_models_models_shia_v1(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,string,float*,float*,float*,int*,int*,int*,int*,float*,float*,float*,float*,float*,float*,float*,float*,float*,float*,string,string,string,string,string,string,string,float*,string,string,size_t,size_t,size_t,size_t,size_t,size_t,size_t,size_t,size_t,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string ruta_bin = NULL;
  int slen(ruta_bin);
  PyObject *ruta_bin_capi = Py_None;
  string ruta_hdr = NULL;
  int slen(ruta_hdr);
  PyObject *ruta_hdr_capi = Py_None;
  float *calib = NULL;
  npy_intp calib_Dims[1] = {-1};
  const int calib_Rank = 1;
  PyArrayObject *capi_calib_tmp = NULL;
  int capi_calib_intent = 0;
  PyObject *calib_capi = Py_None;
  float *stoin = NULL;
  npy_intp stoin_Dims[2] = {-1, -1};
  const int stoin_Rank = 2;
  PyArrayObject *capi_stoin_tmp = NULL;
  int capi_stoin_intent = 0;
  PyObject *stoin_capi = Py_None;
  float *hspeedin = NULL;
  npy_intp hspeedin_Dims[2] = {-1, -1};
  const int hspeedin_Rank = 2;
  PyArrayObject *capi_hspeedin_tmp = NULL;
  int capi_hspeedin_intent = 0;
  PyObject *hspeedin_capi = Py_None;
  int n_cel = 0;
  PyObject *n_cel_capi = Py_None;
  int n_cont = 0;
  PyObject *n_cont_capi = Py_None;
  int n_conth = 0;
  PyObject *n_conth_capi = Py_None;
  int n_reg = 0;
  PyObject *n_reg_capi = Py_None;
  float *q = NULL;
  npy_intp q_Dims[2] = {-1, -1};
  const int q_Rank = 2;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  float *qsed = NULL;
  npy_intp qsed_Dims[3] = {-1, -1, -1};
  const int qsed_Rank = 3;
  PyArrayObject *capi_qsed_tmp = NULL;
  int capi_qsed_intent = 0;
  float *qseparated = NULL;
  npy_intp qseparated_Dims[3] = {-1, -1, -1};
  const int qseparated_Rank = 3;
  PyArrayObject *capi_qseparated_tmp = NULL;
  int capi_qseparated_intent = 0;
  float *hum = NULL;
  npy_intp hum_Dims[2] = {-1, -1};
  const int hum_Rank = 2;
  PyArrayObject *capi_hum_tmp = NULL;
  int capi_hum_intent = 0;
  float *st1 = NULL;
  npy_intp st1_Dims[2] = {-1, -1};
  const int st1_Rank = 2;
  PyArrayObject *capi_st1_tmp = NULL;
  int capi_st1_intent = 0;
  float *st3 = NULL;
  npy_intp st3_Dims[2] = {-1, -1};
  const int st3_Rank = 2;
  PyArrayObject *capi_st3_tmp = NULL;
  int capi_st3_intent = 0;
  float *balance = NULL;
  npy_intp balance_Dims[1] = {-1};
  const int balance_Rank = 1;
  PyArrayObject *capi_balance_tmp = NULL;
  int capi_balance_intent = 0;
  float *speed = NULL;
  npy_intp speed_Dims[2] = {-1, -1};
  const int speed_Rank = 2;
  PyArrayObject *capi_speed_tmp = NULL;
  int capi_speed_intent = 0;
  float *areacontrol = NULL;
  npy_intp areacontrol_Dims[2] = {-1, -1};
  const int areacontrol_Rank = 2;
  PyArrayObject *capi_areacontrol_tmp = NULL;
  int capi_areacontrol_intent = 0;
  float *stoout = NULL;
  npy_intp stoout_Dims[2] = {-1, -1};
  const int stoout_Rank = 2;
  PyArrayObject *capi_stoout_tmp = NULL;
  int capi_stoout_intent = 0;
  string ruta_storage = NULL;
  int slen(ruta_storage);
  PyObject *ruta_storage_capi = Py_None;
  string ruta_speed = NULL;
  int slen(ruta_speed);
  PyObject *ruta_speed_capi = Py_None;
  string ruta_vfluxes = NULL;
  int slen(ruta_vfluxes);
  PyObject *ruta_vfluxes_capi = Py_None;
  string ruta_binconv = NULL;
  int slen(ruta_binconv);
  PyObject *ruta_binconv_capi = Py_None;
  string ruta_binstra = NULL;
  int slen(ruta_binstra);
  PyObject *ruta_binstra_capi = Py_None;
  string ruta_hdrconv = NULL;
  int slen(ruta_hdrconv);
  PyObject *ruta_hdrconv_capi = Py_None;
  string ruta_hdrstra = NULL;
  int slen(ruta_hdrstra);
  PyObject *ruta_hdrstra_capi = Py_None;
  float *qsep_byrain = NULL;
  npy_intp qsep_byrain_Dims[3] = {-1, -1, -1};
  const int qsep_byrain_Rank = 3;
  PyArrayObject *capi_qsep_byrain_tmp = NULL;
  int capi_qsep_byrain_intent = 0;
  string ruta_retorno = NULL;
  int slen(ruta_retorno);
  PyObject *ruta_retorno_capi = Py_None;
  string ruta_rc = NULL;
  int slen(ruta_rc);
  PyObject *ruta_rc_capi = Py_None;
  static char *capi_kwlist[] = {"ruta_bin","ruta_hdr","calib","n_cont","n_conth","n_reg","stoin","hspeedin","n_cel","ruta_storage","ruta_speed","ruta_vfluxes","ruta_binconv","ruta_binstra","ruta_hdrconv","ruta_hdrstra","ruta_retorno","ruta_rc",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOO|OOOOOOOOOOOO:models.models.shia_v1",\
    capi_kwlist,&ruta_bin_capi,&ruta_hdr_capi,&calib_capi,&n_cont_capi,&n_conth_capi,&n_reg_capi,&stoin_capi,&hspeedin_capi,&n_cel_capi,&ruta_storage_capi,&ruta_speed_capi,&ruta_vfluxes_capi,&ruta_binconv_capi,&ruta_binstra_capi,&ruta_hdrconv_capi,&ruta_hdrstra_capi,&ruta_retorno_capi,&ruta_rc_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n_reg */
    f2py_success = int_from_pyobj(&n_reg,n_reg_capi,"models.models.shia_v1() 6th argument (n_reg) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n_cont */
    f2py_success = int_from_pyobj(&n_cont,n_cont_capi,"models.models.shia_v1() 4th argument (n_cont) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n_conth */
    f2py_success = int_from_pyobj(&n_conth,n_conth_capi,"models.models.shia_v1() 5th argument (n_conth) can't be converted to int");
  if (f2py_success) {
  /* Processing variable calib */
  calib_Dims[0]=11;
  capi_calib_intent |= F2PY_INTENT_IN;
  capi_calib_tmp = array_from_pyobj(NPY_FLOAT,calib_Dims,calib_Rank,capi_calib_intent,calib_capi);
  if (capi_calib_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 3rd argument `calib' of models.models.shia_v1 to C/Fortran array" );
  } else {
    calib = (float *)(PyArray_DATA(capi_calib_tmp));

  /* Processing variable ruta_bin */
  slen(ruta_bin) = 500;
  f2py_success = string_from_pyobj(&ruta_bin,&slen(ruta_bin),"",ruta_bin_capi,"string_from_pyobj failed in converting 1st argument `ruta_bin' of models.models.shia_v1 to C string");
  if (f2py_success) {
  /* Processing variable ruta_hdr */
  slen(ruta_hdr) = 500;
  f2py_success = string_from_pyobj(&ruta_hdr,&slen(ruta_hdr),"",ruta_hdr_capi,"string_from_pyobj failed in converting 2nd argument `ruta_hdr' of models.models.shia_v1 to C string");
  if (f2py_success) {
  /* Processing variable ruta_storage */
  slen(ruta_storage) = 500;
  f2py_success = string_from_pyobj(&ruta_storage,&slen(ruta_storage),"",ruta_storage_capi,"string_from_pyobj failed in converting 4th keyword `ruta_storage' of models.models.shia_v1 to C string");
  if (f2py_success) {
  /* Processing variable ruta_binconv */
  slen(ruta_binconv) = 500;
  f2py_success = string_from_pyobj(&ruta_binconv,&slen(ruta_binconv),"",ruta_binconv_capi,"string_from_pyobj failed in converting 7th keyword `ruta_binconv' of models.models.shia_v1 to C string");
  if (f2py_success) {
  /* Processing variable ruta_hdrconv */
  slen(ruta_hdrconv) = 500;
  f2py_success = string_from_pyobj(&ruta_hdrconv,&slen(ruta_hdrconv),"",ruta_hdrconv_capi,"string_from_pyobj failed in converting 9th keyword `ruta_hdrconv' of models.models.shia_v1 to C string");
  if (f2py_success) {
  /* Processing variable ruta_binstra */
  slen(ruta_binstra) = 500;
  f2py_success = string_from_pyobj(&ruta_binstra,&slen(ruta_binstra),"",ruta_binstra_capi,"string_from_pyobj failed in converting 8th keyword `ruta_binstra' of models.models.shia_v1 to C string");
  if (f2py_success) {
  /* Processing variable ruta_hdrstra */
  slen(ruta_hdrstra) = 500;
  f2py_success = string_from_pyobj(&ruta_hdrstra,&slen(ruta_hdrstra),"",ruta_hdrstra_capi,"string_from_pyobj failed in converting 10th keyword `ruta_hdrstra' of models.models.shia_v1 to C string");
  if (f2py_success) {
  /* Processing variable ruta_speed */
  slen(ruta_speed) = 500;
  f2py_success = string_from_pyobj(&ruta_speed,&slen(ruta_speed),"",ruta_speed_capi,"string_from_pyobj failed in converting 5th keyword `ruta_speed' of models.models.shia_v1 to C string");
  if (f2py_success) {
  /* Processing variable ruta_retorno */
  slen(ruta_retorno) = 500;
  f2py_success = string_from_pyobj(&ruta_retorno,&slen(ruta_retorno),"",ruta_retorno_capi,"string_from_pyobj failed in converting 11st keyword `ruta_retorno' of models.models.shia_v1 to C string");
  if (f2py_success) {
  /* Processing variable ruta_vfluxes */
  slen(ruta_vfluxes) = 500;
  f2py_success = string_from_pyobj(&ruta_vfluxes,&slen(ruta_vfluxes),"",ruta_vfluxes_capi,"string_from_pyobj failed in converting 6th keyword `ruta_vfluxes' of models.models.shia_v1 to C string");
  if (f2py_success) {
  /* Processing variable ruta_rc */
  slen(ruta_rc) = 500;
  f2py_success = string_from_pyobj(&ruta_rc,&slen(ruta_rc),"",ruta_rc_capi,"string_from_pyobj failed in converting 12nd keyword `ruta_rc' of models.models.shia_v1 to C string");
  if (f2py_success) {
  /* Processing variable stoin */
  stoin_Dims[0]=5;
  capi_stoin_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_stoin_tmp = array_from_pyobj(NPY_FLOAT,stoin_Dims,stoin_Rank,capi_stoin_intent,stoin_capi);
  if (capi_stoin_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 1st keyword `stoin' of models.models.shia_v1 to C/Fortran array" );
  } else {
    stoin = (float *)(PyArray_DATA(capi_stoin_tmp));

  /* Processing variable n_cel */
  if (n_cel_capi == Py_None) n_cel = shape(stoin,1); else
    f2py_success = int_from_pyobj(&n_cel,n_cel_capi,"models.models.shia_v1() 3rd keyword (n_cel) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(stoin,1)==n_cel,"shape(stoin,1)==n_cel","3rd keyword n_cel","shia_v1:n_cel=%d",n_cel) {
  /* Processing variable hspeedin */
  hspeedin_Dims[0]=4,hspeedin_Dims[1]=n_cel;
  capi_hspeedin_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_hspeedin_tmp = array_from_pyobj(NPY_FLOAT,hspeedin_Dims,hspeedin_Rank,capi_hspeedin_intent,hspeedin_capi);
  if (capi_hspeedin_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 2nd keyword `hspeedin' of models.models.shia_v1 to C/Fortran array" );
  } else {
    hspeedin = (float *)(PyArray_DATA(capi_hspeedin_tmp));

  /* Processing variable hum */
  hum_Dims[0]=n_conth,hum_Dims[1]=n_reg;
  capi_hum_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_hum_tmp = array_from_pyobj(NPY_FLOAT,hum_Dims,hum_Rank,capi_hum_intent,Py_None);
  if (capi_hum_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `hum' of models.models.shia_v1 to C/Fortran array" );
  } else {
    hum = (float *)(PyArray_DATA(capi_hum_tmp));

  /* Processing variable st1 */
  st1_Dims[0]=n_conth,st1_Dims[1]=n_reg;
  capi_st1_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_st1_tmp = array_from_pyobj(NPY_FLOAT,st1_Dims,st1_Rank,capi_st1_intent,Py_None);
  if (capi_st1_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `st1' of models.models.shia_v1 to C/Fortran array" );
  } else {
    st1 = (float *)(PyArray_DATA(capi_st1_tmp));

  /* Processing variable st3 */
  st3_Dims[0]=n_conth,st3_Dims[1]=n_reg;
  capi_st3_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_st3_tmp = array_from_pyobj(NPY_FLOAT,st3_Dims,st3_Rank,capi_st3_intent,Py_None);
  if (capi_st3_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `st3' of models.models.shia_v1 to C/Fortran array" );
  } else {
    st3 = (float *)(PyArray_DATA(capi_st3_tmp));

  /* Processing variable q */
  q_Dims[0]=n_cont,q_Dims[1]=n_reg;
  capi_q_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_q_tmp = array_from_pyobj(NPY_FLOAT,q_Dims,q_Rank,capi_q_intent,Py_None);
  if (capi_q_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `q' of models.models.shia_v1 to C/Fortran array" );
  } else {
    q = (float *)(PyArray_DATA(capi_q_tmp));

  /* Processing variable qsed */
  qsed_Dims[0]=n_cont,qsed_Dims[1]=3,qsed_Dims[2]=n_reg;
  capi_qsed_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_qsed_tmp = array_from_pyobj(NPY_FLOAT,qsed_Dims,qsed_Rank,capi_qsed_intent,Py_None);
  if (capi_qsed_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `qsed' of models.models.shia_v1 to C/Fortran array" );
  } else {
    qsed = (float *)(PyArray_DATA(capi_qsed_tmp));

  /* Processing variable qseparated */
  qseparated_Dims[0]=n_cont,qseparated_Dims[1]=3,qseparated_Dims[2]=n_reg;
  capi_qseparated_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_qseparated_tmp = array_from_pyobj(NPY_FLOAT,qseparated_Dims,qseparated_Rank,capi_qseparated_intent,Py_None);
  if (capi_qseparated_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `qseparated' of models.models.shia_v1 to C/Fortran array" );
  } else {
    qseparated = (float *)(PyArray_DATA(capi_qseparated_tmp));

  /* Processing variable qsep_byrain */
  qsep_byrain_Dims[0]=n_cont,qsep_byrain_Dims[1]=2,qsep_byrain_Dims[2]=n_reg;
  capi_qsep_byrain_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_qsep_byrain_tmp = array_from_pyobj(NPY_FLOAT,qsep_byrain_Dims,qsep_byrain_Rank,capi_qsep_byrain_intent,Py_None);
  if (capi_qsep_byrain_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `qsep_byrain' of models.models.shia_v1 to C/Fortran array" );
  } else {
    qsep_byrain = (float *)(PyArray_DATA(capi_qsep_byrain_tmp));

  /* Processing variable stoout */
  stoout_Dims[0]=5,stoout_Dims[1]=n_cel;
  capi_stoout_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_stoout_tmp = array_from_pyobj(NPY_FLOAT,stoout_Dims,stoout_Rank,capi_stoout_intent,Py_None);
  if (capi_stoout_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `stoout' of models.models.shia_v1 to C/Fortran array" );
  } else {
    stoout = (float *)(PyArray_DATA(capi_stoout_tmp));

  /* Processing variable balance */
  balance_Dims[0]=n_reg;
  capi_balance_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_balance_tmp = array_from_pyobj(NPY_FLOAT,balance_Dims,balance_Rank,capi_balance_intent,Py_None);
  if (capi_balance_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `balance' of models.models.shia_v1 to C/Fortran array" );
  } else {
    balance = (float *)(PyArray_DATA(capi_balance_tmp));

  /* Processing variable speed */
  speed_Dims[0]=n_cont,speed_Dims[1]=n_reg;
  capi_speed_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_speed_tmp = array_from_pyobj(NPY_FLOAT,speed_Dims,speed_Rank,capi_speed_intent,Py_None);
  if (capi_speed_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `speed' of models.models.shia_v1 to C/Fortran array" );
  } else {
    speed = (float *)(PyArray_DATA(capi_speed_tmp));

  /* Processing variable areacontrol */
  areacontrol_Dims[0]=n_cont,areacontrol_Dims[1]=n_reg;
  capi_areacontrol_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_areacontrol_tmp = array_from_pyobj(NPY_FLOAT,areacontrol_Dims,areacontrol_Rank,capi_areacontrol_intent,Py_None);
  if (capi_areacontrol_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `areacontrol' of models.models.shia_v1 to C/Fortran array" );
  } else {
    areacontrol = (float *)(PyArray_DATA(capi_areacontrol_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(ruta_bin,ruta_hdr,calib,stoin,hspeedin,&n_cel,&n_cont,&n_conth,&n_reg,q,qsed,qseparated,hum,st1,st3,balance,speed,areacontrol,stoout,ruta_storage,ruta_speed,ruta_vfluxes,ruta_binconv,ruta_binstra,ruta_hdrconv,ruta_hdrstra,qsep_byrain,ruta_retorno,ruta_rc,slen(ruta_bin),slen(ruta_hdr),slen(ruta_storage),slen(ruta_speed),slen(ruta_vfluxes),slen(ruta_binconv),slen(ruta_binstra),slen(ruta_hdrconv),slen(ruta_hdrstra),slen(ruta_retorno),slen(ruta_rc));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("NNNNNNNNNNN",capi_q_tmp,capi_qsed_tmp,capi_qseparated_tmp,capi_hum_tmp,capi_st1_tmp,capi_st3_tmp,capi_balance_tmp,capi_speed_tmp,capi_areacontrol_tmp,capi_stoout_tmp,capi_qsep_byrain_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_areacontrol_tmp == NULL) ... else of areacontrol*/
  /* End of cleaning variable areacontrol */
  }  /*if (capi_speed_tmp == NULL) ... else of speed*/
  /* End of cleaning variable speed */
  }  /*if (capi_balance_tmp == NULL) ... else of balance*/
  /* End of cleaning variable balance */
  }  /*if (capi_stoout_tmp == NULL) ... else of stoout*/
  /* End of cleaning variable stoout */
  }  /*if (capi_qsep_byrain_tmp == NULL) ... else of qsep_byrain*/
  /* End of cleaning variable qsep_byrain */
  }  /*if (capi_qseparated_tmp == NULL) ... else of qseparated*/
  /* End of cleaning variable qseparated */
  }  /*if (capi_qsed_tmp == NULL) ... else of qsed*/
  /* End of cleaning variable qsed */
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
  }  /*if (capi_st3_tmp == NULL) ... else of st3*/
  /* End of cleaning variable st3 */
  }  /*if (capi_st1_tmp == NULL) ... else of st1*/
  /* End of cleaning variable st1 */
  }  /*if (capi_hum_tmp == NULL) ... else of hum*/
  /* End of cleaning variable hum */
  if((PyObject *)capi_hspeedin_tmp!=hspeedin_capi) {
    Py_XDECREF(capi_hspeedin_tmp); }
  }  /*if (capi_hspeedin_tmp == NULL) ... else of hspeedin*/
  /* End of cleaning variable hspeedin */
  } /*CHECKSCALAR(shape(stoin,1)==n_cel)*/
  } /*if (f2py_success) of n_cel*/
  /* End of cleaning variable n_cel */
  if((PyObject *)capi_stoin_tmp!=stoin_capi) {
    Py_XDECREF(capi_stoin_tmp); }
  }  /*if (capi_stoin_tmp == NULL) ... else of stoin*/
  /* End of cleaning variable stoin */
    STRINGFREE(ruta_rc);
  }  /*if (f2py_success) of ruta_rc*/
  /* End of cleaning variable ruta_rc */
    STRINGFREE(ruta_vfluxes);
  }  /*if (f2py_success) of ruta_vfluxes*/
  /* End of cleaning variable ruta_vfluxes */
    STRINGFREE(ruta_retorno);
  }  /*if (f2py_success) of ruta_retorno*/
  /* End of cleaning variable ruta_retorno */
    STRINGFREE(ruta_speed);
  }  /*if (f2py_success) of ruta_speed*/
  /* End of cleaning variable ruta_speed */
    STRINGFREE(ruta_hdrstra);
  }  /*if (f2py_success) of ruta_hdrstra*/
  /* End of cleaning variable ruta_hdrstra */
    STRINGFREE(ruta_binstra);
  }  /*if (f2py_success) of ruta_binstra*/
  /* End of cleaning variable ruta_binstra */
    STRINGFREE(ruta_hdrconv);
  }  /*if (f2py_success) of ruta_hdrconv*/
  /* End of cleaning variable ruta_hdrconv */
    STRINGFREE(ruta_binconv);
  }  /*if (f2py_success) of ruta_binconv*/
  /* End of cleaning variable ruta_binconv */
    STRINGFREE(ruta_storage);
  }  /*if (f2py_success) of ruta_storage*/
  /* End of cleaning variable ruta_storage */
    STRINGFREE(ruta_hdr);
  }  /*if (f2py_success) of ruta_hdr*/
  /* End of cleaning variable ruta_hdr */
    STRINGFREE(ruta_bin);
  }  /*if (f2py_success) of ruta_bin*/
  /* End of cleaning variable ruta_bin */
  if((PyObject *)capi_calib_tmp!=calib_capi) {
    Py_XDECREF(capi_calib_tmp); }
  }  /*if (capi_calib_tmp == NULL) ... else of calib*/
  /* End of cleaning variable calib */
  } /*if (f2py_success) of n_conth*/
  /* End of cleaning variable n_conth */
  } /*if (f2py_success) of n_cont*/
  /* End of cleaning variable n_cont */
  } /*if (f2py_success) of n_reg*/
  /* End of cleaning variable n_reg */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of shia_v1 *******************************/

/****************************** read_float_basin ******************************/
static char doc_f2py_rout_models_models_read_float_basin[] = "\
vect,res = read_float_basin(ruta,record,n_cel)\n\nWrapper for ``read_float_basin``.\
\n\nParameters\n----------\n"
"ruta : input string(len=500)\n"
"record : input int\n"
"n_cel : input int\n"
"\nReturns\n-------\n"
"vect : rank-1 array('f') with bounds (n_cel)\n"
"res : int";
/*  */
static PyObject *f2py_rout_models_models_read_float_basin(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,int*,int*,float*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string ruta = NULL;
  int slen(ruta);
  PyObject *ruta_capi = Py_None;
  int record = 0;
  PyObject *record_capi = Py_None;
  int n_cel = 0;
  PyObject *n_cel_capi = Py_None;
  float *vect = NULL;
  npy_intp vect_Dims[1] = {-1};
  const int vect_Rank = 1;
  PyArrayObject *capi_vect_tmp = NULL;
  int capi_vect_intent = 0;
  int res = 0;
  static char *capi_kwlist[] = {"ruta","record","n_cel",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:models.models.read_float_basin",\
    capi_kwlist,&ruta_capi,&record_capi,&n_cel_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable record */
    f2py_success = int_from_pyobj(&record,record_capi,"models.models.read_float_basin() 2nd argument (record) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n_cel */
    f2py_success = int_from_pyobj(&n_cel,n_cel_capi,"models.models.read_float_basin() 3rd argument (n_cel) can't be converted to int");
  if (f2py_success) {
  /* Processing variable ruta */
  slen(ruta) = 500;
  f2py_success = string_from_pyobj(&ruta,&slen(ruta),"",ruta_capi,"string_from_pyobj failed in converting 1st argument `ruta' of models.models.read_float_basin to C string");
  if (f2py_success) {
  /* Processing variable res */
  /* Processing variable vect */
  vect_Dims[0]=n_cel;
  capi_vect_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_vect_tmp = array_from_pyobj(NPY_FLOAT,vect_Dims,vect_Rank,capi_vect_intent,Py_None);
  if (capi_vect_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `vect' of models.models.read_float_basin to C/Fortran array" );
  } else {
    vect = (float *)(PyArray_DATA(capi_vect_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(ruta,&record,&n_cel,vect,&res,slen(ruta));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("Ni",capi_vect_tmp,res);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_vect_tmp == NULL) ... else of vect*/
  /* End of cleaning variable vect */
  /* End of cleaning variable res */
    STRINGFREE(ruta);
  }  /*if (f2py_success) of ruta*/
  /* End of cleaning variable ruta */
  } /*if (f2py_success) of n_cel*/
  /* End of cleaning variable n_cel */
  } /*if (f2py_success) of record*/
  /* End of cleaning variable record */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of read_float_basin **************************/

/*************************** read_float_basin_ncol ***************************/
static char doc_f2py_rout_models_models_read_float_basin_ncol[] = "\
vect,res = read_float_basin_ncol(ruta,record,n_cel,n_col)\n\nWrapper for ``read_float_basin_ncol``.\
\n\nParameters\n----------\n"
"ruta : input string(len=500)\n"
"record : input int\n"
"n_cel : input int\n"
"n_col : input int\n"
"\nReturns\n-------\n"
"vect : rank-2 array('f') with bounds (n_col,n_cel)\n"
"res : int";
/*  */
static PyObject *f2py_rout_models_models_read_float_basin_ncol(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,int*,int*,int*,float*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string ruta = NULL;
  int slen(ruta);
  PyObject *ruta_capi = Py_None;
  int record = 0;
  PyObject *record_capi = Py_None;
  int n_cel = 0;
  PyObject *n_cel_capi = Py_None;
  int n_col = 0;
  PyObject *n_col_capi = Py_None;
  float *vect = NULL;
  npy_intp vect_Dims[2] = {-1, -1};
  const int vect_Rank = 2;
  PyArrayObject *capi_vect_tmp = NULL;
  int capi_vect_intent = 0;
  int res = 0;
  static char *capi_kwlist[] = {"ruta","record","n_cel","n_col",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:models.models.read_float_basin_ncol",\
    capi_kwlist,&ruta_capi,&record_capi,&n_cel_capi,&n_col_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable record */
    f2py_success = int_from_pyobj(&record,record_capi,"models.models.read_float_basin_ncol() 2nd argument (record) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n_cel */
    f2py_success = int_from_pyobj(&n_cel,n_cel_capi,"models.models.read_float_basin_ncol() 3rd argument (n_cel) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n_col */
    f2py_success = int_from_pyobj(&n_col,n_col_capi,"models.models.read_float_basin_ncol() 4th argument (n_col) can't be converted to int");
  if (f2py_success) {
  /* Processing variable ruta */
  slen(ruta) = 500;
  f2py_success = string_from_pyobj(&ruta,&slen(ruta),"",ruta_capi,"string_from_pyobj failed in converting 1st argument `ruta' of models.models.read_float_basin_ncol to C string");
  if (f2py_success) {
  /* Processing variable res */
  /* Processing variable vect */
  vect_Dims[0]=n_col,vect_Dims[1]=n_cel;
  capi_vect_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_vect_tmp = array_from_pyobj(NPY_FLOAT,vect_Dims,vect_Rank,capi_vect_intent,Py_None);
  if (capi_vect_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `vect' of models.models.read_float_basin_ncol to C/Fortran array" );
  } else {
    vect = (float *)(PyArray_DATA(capi_vect_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(ruta,&record,&n_cel,&n_col,vect,&res,slen(ruta));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("Ni",capi_vect_tmp,res);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_vect_tmp == NULL) ... else of vect*/
  /* End of cleaning variable vect */
  /* End of cleaning variable res */
    STRINGFREE(ruta);
  }  /*if (f2py_success) of ruta*/
  /* End of cleaning variable ruta */
  } /*if (f2py_success) of n_col*/
  /* End of cleaning variable n_col */
  } /*if (f2py_success) of n_cel*/
  /* End of cleaning variable n_cel */
  } /*if (f2py_success) of record*/
  /* End of cleaning variable record */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of read_float_basin_ncol ************************/

/******************************* read_int_basin *******************************/
static char doc_f2py_rout_models_models_read_int_basin[] = "\
vect,res = read_int_basin(ruta,record,n_cel)\n\nWrapper for ``read_int_basin``.\
\n\nParameters\n----------\n"
"ruta : input string(len=500)\n"
"record : input int\n"
"n_cel : input int\n"
"\nReturns\n-------\n"
"vect : rank-1 array('i') with bounds (n_cel)\n"
"res : int";
/*  */
static PyObject *f2py_rout_models_models_read_int_basin(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,int*,int*,int*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string ruta = NULL;
  int slen(ruta);
  PyObject *ruta_capi = Py_None;
  int record = 0;
  PyObject *record_capi = Py_None;
  int n_cel = 0;
  PyObject *n_cel_capi = Py_None;
  int *vect = NULL;
  npy_intp vect_Dims[1] = {-1};
  const int vect_Rank = 1;
  PyArrayObject *capi_vect_tmp = NULL;
  int capi_vect_intent = 0;
  int res = 0;
  static char *capi_kwlist[] = {"ruta","record","n_cel",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:models.models.read_int_basin",\
    capi_kwlist,&ruta_capi,&record_capi,&n_cel_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable record */
    f2py_success = int_from_pyobj(&record,record_capi,"models.models.read_int_basin() 2nd argument (record) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n_cel */
    f2py_success = int_from_pyobj(&n_cel,n_cel_capi,"models.models.read_int_basin() 3rd argument (n_cel) can't be converted to int");
  if (f2py_success) {
  /* Processing variable ruta */
  slen(ruta) = 500;
  f2py_success = string_from_pyobj(&ruta,&slen(ruta),"",ruta_capi,"string_from_pyobj failed in converting 1st argument `ruta' of models.models.read_int_basin to C string");
  if (f2py_success) {
  /* Processing variable res */
  /* Processing variable vect */
  vect_Dims[0]=n_cel;
  capi_vect_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_vect_tmp = array_from_pyobj(NPY_INT,vect_Dims,vect_Rank,capi_vect_intent,Py_None);
  if (capi_vect_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `vect' of models.models.read_int_basin to C/Fortran array" );
  } else {
    vect = (int *)(PyArray_DATA(capi_vect_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(ruta,&record,&n_cel,vect,&res,slen(ruta));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("Ni",capi_vect_tmp,res);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_vect_tmp == NULL) ... else of vect*/
  /* End of cleaning variable vect */
  /* End of cleaning variable res */
    STRINGFREE(ruta);
  }  /*if (f2py_success) of ruta*/
  /* End of cleaning variable ruta */
  } /*if (f2py_success) of n_cel*/
  /* End of cleaning variable n_cel */
  } /*if (f2py_success) of record*/
  /* End of cleaning variable record */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of read_int_basin ***************************/

/***************************** write_float_basin *****************************/
static char doc_f2py_rout_models_models_write_float_basin[] = "\
write_float_basin(ruta,vect,record,[n_cel,n_col])\n\nWrapper for ``write_float_basin``.\
\n\nParameters\n----------\n"
"ruta : input string(len=255)\n"
"vect : input rank-2 array('f') with bounds (n_col,n_cel)\n"
"record : input int\n"
"\nOther Parameters\n----------------\n"
"n_cel : input int, optional\n    Default: shape(vect,1)\n"
"n_col : input int, optional\n    Default: shape(vect,0)";
/*  */
static PyObject *f2py_rout_models_models_write_float_basin(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,float*,int*,int*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string ruta = NULL;
  int slen(ruta);
  PyObject *ruta_capi = Py_None;
  float *vect = NULL;
  npy_intp vect_Dims[2] = {-1, -1};
  const int vect_Rank = 2;
  PyArrayObject *capi_vect_tmp = NULL;
  int capi_vect_intent = 0;
  PyObject *vect_capi = Py_None;
  int record = 0;
  PyObject *record_capi = Py_None;
  int n_cel = 0;
  PyObject *n_cel_capi = Py_None;
  int n_col = 0;
  PyObject *n_col_capi = Py_None;
  static char *capi_kwlist[] = {"ruta","vect","record","n_cel","n_col",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO|OO:models.models.write_float_basin",\
    capi_kwlist,&ruta_capi,&vect_capi,&record_capi,&n_cel_capi,&n_col_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable record */
    f2py_success = int_from_pyobj(&record,record_capi,"models.models.write_float_basin() 3rd argument (record) can't be converted to int");
  if (f2py_success) {
  /* Processing variable ruta */
  slen(ruta) = 255;
  f2py_success = string_from_pyobj(&ruta,&slen(ruta),"",ruta_capi,"string_from_pyobj failed in converting 1st argument `ruta' of models.models.write_float_basin to C string");
  if (f2py_success) {
  /* Processing variable vect */
  ;
  capi_vect_intent |= F2PY_INTENT_IN;
  capi_vect_tmp = array_from_pyobj(NPY_FLOAT,vect_Dims,vect_Rank,capi_vect_intent,vect_capi);
  if (capi_vect_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 2nd argument `vect' of models.models.write_float_basin to C/Fortran array" );
  } else {
    vect = (float *)(PyArray_DATA(capi_vect_tmp));

  /* Processing variable n_cel */
  if (n_cel_capi == Py_None) n_cel = shape(vect,1); else
    f2py_success = int_from_pyobj(&n_cel,n_cel_capi,"models.models.write_float_basin() 1st keyword (n_cel) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(vect,1)==n_cel,"shape(vect,1)==n_cel","1st keyword n_cel","write_float_basin:n_cel=%d",n_cel) {
  /* Processing variable n_col */
  if (n_col_capi == Py_None) n_col = shape(vect,0); else
    f2py_success = int_from_pyobj(&n_col,n_col_capi,"models.models.write_float_basin() 2nd keyword (n_col) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(vect,0)==n_col,"shape(vect,0)==n_col","2nd keyword n_col","write_float_basin:n_col=%d",n_col) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(ruta,vect,&record,&n_cel,&n_col,slen(ruta));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(vect,0)==n_col)*/
  } /*if (f2py_success) of n_col*/
  /* End of cleaning variable n_col */
  } /*CHECKSCALAR(shape(vect,1)==n_cel)*/
  } /*if (f2py_success) of n_cel*/
  /* End of cleaning variable n_cel */
  if((PyObject *)capi_vect_tmp!=vect_capi) {
    Py_XDECREF(capi_vect_tmp); }
  }  /*if (capi_vect_tmp == NULL) ... else of vect*/
  /* End of cleaning variable vect */
    STRINGFREE(ruta);
  }  /*if (f2py_success) of ruta*/
  /* End of cleaning variable ruta */
  } /*if (f2py_success) of record*/
  /* End of cleaning variable record */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of write_float_basin **************************/

/****************************** write_int_basin ******************************/
static char doc_f2py_rout_models_models_write_int_basin[] = "\
write_int_basin(ruta,vect,record,[n_cel,n_col])\n\nWrapper for ``write_int_basin``.\
\n\nParameters\n----------\n"
"ruta : input string(len=255)\n"
"vect : input rank-2 array('i') with bounds (n_col,n_cel)\n"
"record : input int\n"
"\nOther Parameters\n----------------\n"
"n_cel : input int, optional\n    Default: shape(vect,1)\n"
"n_col : input int, optional\n    Default: shape(vect,0)";
/*  */
static PyObject *f2py_rout_models_models_write_int_basin(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,int*,int*,int*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string ruta = NULL;
  int slen(ruta);
  PyObject *ruta_capi = Py_None;
  int *vect = NULL;
  npy_intp vect_Dims[2] = {-1, -1};
  const int vect_Rank = 2;
  PyArrayObject *capi_vect_tmp = NULL;
  int capi_vect_intent = 0;
  PyObject *vect_capi = Py_None;
  int record = 0;
  PyObject *record_capi = Py_None;
  int n_cel = 0;
  PyObject *n_cel_capi = Py_None;
  int n_col = 0;
  PyObject *n_col_capi = Py_None;
  static char *capi_kwlist[] = {"ruta","vect","record","n_cel","n_col",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO|OO:models.models.write_int_basin",\
    capi_kwlist,&ruta_capi,&vect_capi,&record_capi,&n_cel_capi,&n_col_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable record */
    f2py_success = int_from_pyobj(&record,record_capi,"models.models.write_int_basin() 3rd argument (record) can't be converted to int");
  if (f2py_success) {
  /* Processing variable ruta */
  slen(ruta) = 255;
  f2py_success = string_from_pyobj(&ruta,&slen(ruta),"",ruta_capi,"string_from_pyobj failed in converting 1st argument `ruta' of models.models.write_int_basin to C string");
  if (f2py_success) {
  /* Processing variable vect */
  ;
  capi_vect_intent |= F2PY_INTENT_IN;
  capi_vect_tmp = array_from_pyobj(NPY_INT,vect_Dims,vect_Rank,capi_vect_intent,vect_capi);
  if (capi_vect_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 2nd argument `vect' of models.models.write_int_basin to C/Fortran array" );
  } else {
    vect = (int *)(PyArray_DATA(capi_vect_tmp));

  /* Processing variable n_cel */
  if (n_cel_capi == Py_None) n_cel = shape(vect,1); else
    f2py_success = int_from_pyobj(&n_cel,n_cel_capi,"models.models.write_int_basin() 1st keyword (n_cel) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(vect,1)==n_cel,"shape(vect,1)==n_cel","1st keyword n_cel","write_int_basin:n_cel=%d",n_cel) {
  /* Processing variable n_col */
  if (n_col_capi == Py_None) n_col = shape(vect,0); else
    f2py_success = int_from_pyobj(&n_col,n_col_capi,"models.models.write_int_basin() 2nd keyword (n_col) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(vect,0)==n_col,"shape(vect,0)==n_col","2nd keyword n_col","write_int_basin:n_col=%d",n_col) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(ruta,vect,&record,&n_cel,&n_col,slen(ruta));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(vect,0)==n_col)*/
  } /*if (f2py_success) of n_col*/
  /* End of cleaning variable n_col */
  } /*CHECKSCALAR(shape(vect,1)==n_cel)*/
  } /*if (f2py_success) of n_cel*/
  /* End of cleaning variable n_cel */
  if((PyObject *)capi_vect_tmp!=vect_capi) {
    Py_XDECREF(capi_vect_tmp); }
  }  /*if (capi_vect_tmp == NULL) ... else of vect*/
  /* End of cleaning variable vect */
    STRINGFREE(ruta);
  }  /*if (f2py_success) of ruta*/
  /* End of cleaning variable ruta */
  } /*if (f2py_success) of record*/
  /* End of cleaning variable record */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of write_int_basin ***************************/

/*************************** rain_read_ascii_table ***************************/
static char doc_f2py_rout_models_models_rain_read_ascii_table[] = "\
rain_read_ascii_table(ruta,nintervals)\n\nWrapper for ``rain_read_ascii_table``.\
\n\nParameters\n----------\n"
"ruta : input string(len=255)\n"
"nintervals : input int";
/*  */
static PyObject *f2py_rout_models_models_rain_read_ascii_table(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string ruta = NULL;
  int slen(ruta);
  PyObject *ruta_capi = Py_None;
  int nintervals = 0;
  PyObject *nintervals_capi = Py_None;
  static char *capi_kwlist[] = {"ruta","nintervals",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:models.models.rain_read_ascii_table",\
    capi_kwlist,&ruta_capi,&nintervals_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable ruta */
  slen(ruta) = 255;
  f2py_success = string_from_pyobj(&ruta,&slen(ruta),"",ruta_capi,"string_from_pyobj failed in converting 1st argument `ruta' of models.models.rain_read_ascii_table to C string");
  if (f2py_success) {
  /* Processing variable nintervals */
    f2py_success = int_from_pyobj(&nintervals,nintervals_capi,"models.models.rain_read_ascii_table() 2nd argument (nintervals) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(ruta,&nintervals,slen(ruta));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of nintervals*/
  /* End of cleaning variable nintervals */
    STRINGFREE(ruta);
  }  /*if (f2py_success) of ruta*/
  /* End of cleaning variable ruta */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of rain_read_ascii_table ************************/

/*********************** rain_read_ascii_table_separate ***********************/
static char doc_f2py_rout_models_models_rain_read_ascii_table_separate[] = "\
rain_read_ascii_table_separate(rutaconv,rutastra,nintervals)\n\nWrapper for ``rain_read_ascii_table_separate``.\
\n\nParameters\n----------\n"
"rutaconv : input string(len=255)\n"
"rutastra : input string(len=255)\n"
"nintervals : input int";
/*  */
static PyObject *f2py_rout_models_models_rain_read_ascii_table_separate(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(string,string,int*,size_t,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  string rutaconv = NULL;
  int slen(rutaconv);
  PyObject *rutaconv_capi = Py_None;
  string rutastra = NULL;
  int slen(rutastra);
  PyObject *rutastra_capi = Py_None;
  int nintervals = 0;
  PyObject *nintervals_capi = Py_None;
  static char *capi_kwlist[] = {"rutaconv","rutastra","nintervals",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:models.models.rain_read_ascii_table_separate",\
    capi_kwlist,&rutaconv_capi,&rutastra_capi,&nintervals_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable rutaconv */
  slen(rutaconv) = 255;
  f2py_success = string_from_pyobj(&rutaconv,&slen(rutaconv),"",rutaconv_capi,"string_from_pyobj failed in converting 1st argument `rutaconv' of models.models.rain_read_ascii_table_separate to C string");
  if (f2py_success) {
  /* Processing variable rutastra */
  slen(rutastra) = 255;
  f2py_success = string_from_pyobj(&rutastra,&slen(rutastra),"",rutastra_capi,"string_from_pyobj failed in converting 2nd argument `rutastra' of models.models.rain_read_ascii_table_separate to C string");
  if (f2py_success) {
  /* Processing variable nintervals */
    f2py_success = int_from_pyobj(&nintervals,nintervals_capi,"models.models.rain_read_ascii_table_separate() 3rd argument (nintervals) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(rutaconv,rutastra,&nintervals,slen(rutaconv),slen(rutastra));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of nintervals*/
  /* End of cleaning variable nintervals */
    STRINGFREE(rutastra);
  }  /*if (f2py_success) of rutastra*/
  /* End of cleaning variable rutastra */
    STRINGFREE(rutaconv);
  }  /*if (f2py_success) of rutaconv*/
  /* End of cleaning variable rutaconv */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************* end of rain_read_ascii_table_separate *******************/

/******************************** rain_pre_mit ********************************/
static char doc_f2py_rout_models_models_rain_pre_mit[] = "\
tin_perte = rain_pre_mit(xy_basin,tin,coord,[nceldas,ntin,ncoord])\n\nWrapper for ``rain_pre_mit``.\
\n\nParameters\n----------\n"
"xy_basin : input rank-2 array('f') with bounds (2,nceldas)\n"
"tin : input rank-2 array('i') with bounds (3,ntin)\n"
"coord : input rank-2 array('f') with bounds (2,ncoord)\n"
"\nOther Parameters\n----------------\n"
"nceldas : input int, optional\n    Default: shape(xy_basin,1)\n"
"ntin : input int, optional\n    Default: shape(tin,1)\n"
"ncoord : input int, optional\n    Default: shape(coord,1)\n"
"\nReturns\n-------\n"
"tin_perte : rank-2 array('i') with bounds (1,nceldas)";
/*  */
static PyObject *f2py_rout_models_models_rain_pre_mit(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,float*,int*,float*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int *tin_perte = NULL;
  npy_intp tin_perte_Dims[2] = {-1, -1};
  const int tin_perte_Rank = 2;
  PyArrayObject *capi_tin_perte_tmp = NULL;
  int capi_tin_perte_intent = 0;
  float *xy_basin = NULL;
  npy_intp xy_basin_Dims[2] = {-1, -1};
  const int xy_basin_Rank = 2;
  PyArrayObject *capi_xy_basin_tmp = NULL;
  int capi_xy_basin_intent = 0;
  PyObject *xy_basin_capi = Py_None;
  int *tin = NULL;
  npy_intp tin_Dims[2] = {-1, -1};
  const int tin_Rank = 2;
  PyArrayObject *capi_tin_tmp = NULL;
  int capi_tin_intent = 0;
  PyObject *tin_capi = Py_None;
  float *coord = NULL;
  npy_intp coord_Dims[2] = {-1, -1};
  const int coord_Rank = 2;
  PyArrayObject *capi_coord_tmp = NULL;
  int capi_coord_intent = 0;
  PyObject *coord_capi = Py_None;
  int nceldas = 0;
  PyObject *nceldas_capi = Py_None;
  int ntin = 0;
  PyObject *ntin_capi = Py_None;
  int ncoord = 0;
  PyObject *ncoord_capi = Py_None;
  static char *capi_kwlist[] = {"xy_basin","tin","coord","nceldas","ntin","ncoord",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO|OOO:models.models.rain_pre_mit",\
    capi_kwlist,&xy_basin_capi,&tin_capi,&coord_capi,&nceldas_capi,&ntin_capi,&ncoord_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable tin */
  tin_Dims[0]=3;
  capi_tin_intent |= F2PY_INTENT_IN;
  capi_tin_tmp = array_from_pyobj(NPY_INT,tin_Dims,tin_Rank,capi_tin_intent,tin_capi);
  if (capi_tin_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 2nd argument `tin' of models.models.rain_pre_mit to C/Fortran array" );
  } else {
    tin = (int *)(PyArray_DATA(capi_tin_tmp));

  /* Processing variable coord */
  coord_Dims[0]=2;
  capi_coord_intent |= F2PY_INTENT_IN;
  capi_coord_tmp = array_from_pyobj(NPY_FLOAT,coord_Dims,coord_Rank,capi_coord_intent,coord_capi);
  if (capi_coord_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 3rd argument `coord' of models.models.rain_pre_mit to C/Fortran array" );
  } else {
    coord = (float *)(PyArray_DATA(capi_coord_tmp));

  /* Processing variable xy_basin */
  xy_basin_Dims[0]=2;
  capi_xy_basin_intent |= F2PY_INTENT_IN;
  capi_xy_basin_tmp = array_from_pyobj(NPY_FLOAT,xy_basin_Dims,xy_basin_Rank,capi_xy_basin_intent,xy_basin_capi);
  if (capi_xy_basin_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 1st argument `xy_basin' of models.models.rain_pre_mit to C/Fortran array" );
  } else {
    xy_basin = (float *)(PyArray_DATA(capi_xy_basin_tmp));

  /* Processing variable ntin */
  if (ntin_capi == Py_None) ntin = shape(tin,1); else
    f2py_success = int_from_pyobj(&ntin,ntin_capi,"models.models.rain_pre_mit() 2nd keyword (ntin) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(tin,1)==ntin,"shape(tin,1)==ntin","2nd keyword ntin","rain_pre_mit:ntin=%d",ntin) {
  /* Processing variable nceldas */
  if (nceldas_capi == Py_None) nceldas = shape(xy_basin,1); else
    f2py_success = int_from_pyobj(&nceldas,nceldas_capi,"models.models.rain_pre_mit() 1st keyword (nceldas) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(xy_basin,1)==nceldas,"shape(xy_basin,1)==nceldas","1st keyword nceldas","rain_pre_mit:nceldas=%d",nceldas) {
  /* Processing variable ncoord */
  if (ncoord_capi == Py_None) ncoord = shape(coord,1); else
    f2py_success = int_from_pyobj(&ncoord,ncoord_capi,"models.models.rain_pre_mit() 3rd keyword (ncoord) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(coord,1)==ncoord,"shape(coord,1)==ncoord","3rd keyword ncoord","rain_pre_mit:ncoord=%d",ncoord) {
  /* Processing variable tin_perte */
  tin_perte_Dims[0]=1,tin_perte_Dims[1]=nceldas;
  capi_tin_perte_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_tin_perte_tmp = array_from_pyobj(NPY_INT,tin_perte_Dims,tin_perte_Rank,capi_tin_perte_intent,Py_None);
  if (capi_tin_perte_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `tin_perte' of models.models.rain_pre_mit to C/Fortran array" );
  } else {
    tin_perte = (int *)(PyArray_DATA(capi_tin_perte_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(tin_perte,xy_basin,tin,coord,&nceldas,&ntin,&ncoord);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_tin_perte_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_tin_perte_tmp == NULL) ... else of tin_perte*/
  /* End of cleaning variable tin_perte */
  } /*CHECKSCALAR(shape(coord,1)==ncoord)*/
  } /*if (f2py_success) of ncoord*/
  /* End of cleaning variable ncoord */
  } /*CHECKSCALAR(shape(xy_basin,1)==nceldas)*/
  } /*if (f2py_success) of nceldas*/
  /* End of cleaning variable nceldas */
  } /*CHECKSCALAR(shape(tin,1)==ntin)*/
  } /*if (f2py_success) of ntin*/
  /* End of cleaning variable ntin */
  if((PyObject *)capi_xy_basin_tmp!=xy_basin_capi) {
    Py_XDECREF(capi_xy_basin_tmp); }
  }  /*if (capi_xy_basin_tmp == NULL) ... else of xy_basin*/
  /* End of cleaning variable xy_basin */
  if((PyObject *)capi_coord_tmp!=coord_capi) {
    Py_XDECREF(capi_coord_tmp); }
  }  /*if (capi_coord_tmp == NULL) ... else of coord*/
  /* End of cleaning variable coord */
  if((PyObject *)capi_tin_tmp!=tin_capi) {
    Py_XDECREF(capi_tin_tmp); }
  }  /*if (capi_tin_tmp == NULL) ... else of tin*/
  /* End of cleaning variable tin */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of rain_pre_mit ****************************/

/********************************** rain_mit **********************************/
static char doc_f2py_rout_models_models_rain_mit[] = "\
meanrain,posids = rain_mit(xy_basin,coord,rain,tin,tin_perte,nhills,ruta,umbral,maskvector,[nceldas,ncoord,ntin,nreg])\n\nWrapper for ``rain_mit``.\
\n\nParameters\n----------\n"
"xy_basin : input rank-2 array('f') with bounds (2,nceldas)\n"
"coord : input rank-2 array('f') with bounds (2,ncoord)\n"
"rain : input rank-2 array('f') with bounds (ncoord,nreg)\n"
"tin : input rank-2 array('i') with bounds (3,ntin)\n"
"tin_perte : input rank-2 array('i') with bounds (1,nceldas)\n"
"nhills : input int\n"
"ruta : input string(len=255)\n"
"umbral : input float\n"
"maskvector : input rank-1 array('i') with bounds (nceldas)\n"
"\nOther Parameters\n----------------\n"
"nceldas : input int, optional\n    Default: shape(xy_basin,1)\n"
"ncoord : input int, optional\n    Default: shape(coord,1)\n"
"ntin : input int, optional\n    Default: shape(tin,1)\n"
"nreg : input int, optional\n    Default: shape(rain,1)\n"
"\nReturns\n-------\n"
"meanrain : rank-1 array('f') with bounds (nreg)\n"
"posids : rank-1 array('i') with bounds (nreg)";
/*  */
static PyObject *f2py_rout_models_models_rain_mit(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,float*,int*,int*,int*,int*,int*,int*,int*,string,float*,float*,int*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float *xy_basin = NULL;
  npy_intp xy_basin_Dims[2] = {-1, -1};
  const int xy_basin_Rank = 2;
  PyArrayObject *capi_xy_basin_tmp = NULL;
  int capi_xy_basin_intent = 0;
  PyObject *xy_basin_capi = Py_None;
  float *coord = NULL;
  npy_intp coord_Dims[2] = {-1, -1};
  const int coord_Rank = 2;
  PyArrayObject *capi_coord_tmp = NULL;
  int capi_coord_intent = 0;
  PyObject *coord_capi = Py_None;
  float *rain = NULL;
  npy_intp rain_Dims[2] = {-1, -1};
  const int rain_Rank = 2;
  PyArrayObject *capi_rain_tmp = NULL;
  int capi_rain_intent = 0;
  PyObject *rain_capi = Py_None;
  int *tin = NULL;
  npy_intp tin_Dims[2] = {-1, -1};
  const int tin_Rank = 2;
  PyArrayObject *capi_tin_tmp = NULL;
  int capi_tin_intent = 0;
  PyObject *tin_capi = Py_None;
  int *tin_perte = NULL;
  npy_intp tin_perte_Dims[2] = {-1, -1};
  const int tin_perte_Rank = 2;
  PyArrayObject *capi_tin_perte_tmp = NULL;
  int capi_tin_perte_intent = 0;
  PyObject *tin_perte_capi = Py_None;
  int nceldas = 0;
  PyObject *nceldas_capi = Py_None;
  int nhills = 0;
  PyObject *nhills_capi = Py_None;
  int ncoord = 0;
  PyObject *ncoord_capi = Py_None;
  int ntin = 0;
  PyObject *ntin_capi = Py_None;
  int nreg = 0;
  PyObject *nreg_capi = Py_None;
  string ruta = NULL;
  int slen(ruta);
  PyObject *ruta_capi = Py_None;
  float umbral = 0;
  PyObject *umbral_capi = Py_None;
  float *meanrain = NULL;
  npy_intp meanrain_Dims[1] = {-1};
  const int meanrain_Rank = 1;
  PyArrayObject *capi_meanrain_tmp = NULL;
  int capi_meanrain_intent = 0;
  int *posids = NULL;
  npy_intp posids_Dims[1] = {-1};
  const int posids_Rank = 1;
  PyArrayObject *capi_posids_tmp = NULL;
  int capi_posids_intent = 0;
  int *maskvector = NULL;
  npy_intp maskvector_Dims[1] = {-1};
  const int maskvector_Rank = 1;
  PyArrayObject *capi_maskvector_tmp = NULL;
  int capi_maskvector_intent = 0;
  PyObject *maskvector_capi = Py_None;
  static char *capi_kwlist[] = {"xy_basin","coord","rain","tin","tin_perte","nhills","ruta","umbral","maskvector","nceldas","ncoord","ntin","nreg",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOOOO|OOOO:models.models.rain_mit",\
    capi_kwlist,&xy_basin_capi,&coord_capi,&rain_capi,&tin_capi,&tin_perte_capi,&nhills_capi,&ruta_capi,&umbral_capi,&maskvector_capi,&nceldas_capi,&ncoord_capi,&ntin_capi,&nreg_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable nhills */
    f2py_success = int_from_pyobj(&nhills,nhills_capi,"models.models.rain_mit() 6th argument (nhills) can't be converted to int");
  if (f2py_success) {
  /* Processing variable tin */
  tin_Dims[0]=3;
  capi_tin_intent |= F2PY_INTENT_IN;
  capi_tin_tmp = array_from_pyobj(NPY_INT,tin_Dims,tin_Rank,capi_tin_intent,tin_capi);
  if (capi_tin_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 4th argument `tin' of models.models.rain_mit to C/Fortran array" );
  } else {
    tin = (int *)(PyArray_DATA(capi_tin_tmp));

  /* Processing variable xy_basin */
  xy_basin_Dims[0]=2;
  capi_xy_basin_intent |= F2PY_INTENT_IN;
  capi_xy_basin_tmp = array_from_pyobj(NPY_FLOAT,xy_basin_Dims,xy_basin_Rank,capi_xy_basin_intent,xy_basin_capi);
  if (capi_xy_basin_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 1st argument `xy_basin' of models.models.rain_mit to C/Fortran array" );
  } else {
    xy_basin = (float *)(PyArray_DATA(capi_xy_basin_tmp));

  /* Processing variable coord */
  coord_Dims[0]=2;
  capi_coord_intent |= F2PY_INTENT_IN;
  capi_coord_tmp = array_from_pyobj(NPY_FLOAT,coord_Dims,coord_Rank,capi_coord_intent,coord_capi);
  if (capi_coord_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 2nd argument `coord' of models.models.rain_mit to C/Fortran array" );
  } else {
    coord = (float *)(PyArray_DATA(capi_coord_tmp));

  /* Processing variable umbral */
    f2py_success = float_from_pyobj(&umbral,umbral_capi,"models.models.rain_mit() 8th argument (umbral) can't be converted to float");
  if (f2py_success) {
  /* Processing variable ruta */
  slen(ruta) = 255;
  f2py_success = string_from_pyobj(&ruta,&slen(ruta),"",ruta_capi,"string_from_pyobj failed in converting 7th argument `ruta' of models.models.rain_mit to C string");
  if (f2py_success) {
  /* Processing variable nceldas */
  if (nceldas_capi == Py_None) nceldas = shape(xy_basin,1); else
    f2py_success = int_from_pyobj(&nceldas,nceldas_capi,"models.models.rain_mit() 1st keyword (nceldas) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(xy_basin,1)==nceldas,"shape(xy_basin,1)==nceldas","1st keyword nceldas","rain_mit:nceldas=%d",nceldas) {
  /* Processing variable ncoord */
  if (ncoord_capi == Py_None) ncoord = shape(coord,1); else
    f2py_success = int_from_pyobj(&ncoord,ncoord_capi,"models.models.rain_mit() 2nd keyword (ncoord) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(coord,1)==ncoord,"shape(coord,1)==ncoord","2nd keyword ncoord","rain_mit:ncoord=%d",ncoord) {
  /* Processing variable ntin */
  if (ntin_capi == Py_None) ntin = shape(tin,1); else
    f2py_success = int_from_pyobj(&ntin,ntin_capi,"models.models.rain_mit() 3rd keyword (ntin) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(tin,1)==ntin,"shape(tin,1)==ntin","3rd keyword ntin","rain_mit:ntin=%d",ntin) {
  /* Processing variable tin_perte */
  tin_perte_Dims[0]=1,tin_perte_Dims[1]=nceldas;
  capi_tin_perte_intent |= F2PY_INTENT_IN;
  capi_tin_perte_tmp = array_from_pyobj(NPY_INT,tin_perte_Dims,tin_perte_Rank,capi_tin_perte_intent,tin_perte_capi);
  if (capi_tin_perte_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 5th argument `tin_perte' of models.models.rain_mit to C/Fortran array" );
  } else {
    tin_perte = (int *)(PyArray_DATA(capi_tin_perte_tmp));

  /* Processing variable maskvector */
  maskvector_Dims[0]=nceldas;
  capi_maskvector_intent |= F2PY_INTENT_IN;
  capi_maskvector_tmp = array_from_pyobj(NPY_INT,maskvector_Dims,maskvector_Rank,capi_maskvector_intent,maskvector_capi);
  if (capi_maskvector_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 9th argument `maskvector' of models.models.rain_mit to C/Fortran array" );
  } else {
    maskvector = (int *)(PyArray_DATA(capi_maskvector_tmp));

  /* Processing variable rain */
  rain_Dims[0]=ncoord;
  capi_rain_intent |= F2PY_INTENT_IN;
  capi_rain_tmp = array_from_pyobj(NPY_FLOAT,rain_Dims,rain_Rank,capi_rain_intent,rain_capi);
  if (capi_rain_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 3rd argument `rain' of models.models.rain_mit to C/Fortran array" );
  } else {
    rain = (float *)(PyArray_DATA(capi_rain_tmp));

  /* Processing variable nreg */
  if (nreg_capi == Py_None) nreg = shape(rain,1); else
    f2py_success = int_from_pyobj(&nreg,nreg_capi,"models.models.rain_mit() 4th keyword (nreg) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(rain,1)==nreg,"shape(rain,1)==nreg","4th keyword nreg","rain_mit:nreg=%d",nreg) {
  /* Processing variable meanrain */
  meanrain_Dims[0]=nreg;
  capi_meanrain_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_meanrain_tmp = array_from_pyobj(NPY_FLOAT,meanrain_Dims,meanrain_Rank,capi_meanrain_intent,Py_None);
  if (capi_meanrain_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `meanrain' of models.models.rain_mit to C/Fortran array" );
  } else {
    meanrain = (float *)(PyArray_DATA(capi_meanrain_tmp));

  /* Processing variable posids */
  posids_Dims[0]=nreg;
  capi_posids_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_posids_tmp = array_from_pyobj(NPY_INT,posids_Dims,posids_Rank,capi_posids_intent,Py_None);
  if (capi_posids_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `posids' of models.models.rain_mit to C/Fortran array" );
  } else {
    posids = (int *)(PyArray_DATA(capi_posids_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(xy_basin,coord,rain,tin,tin_perte,&nceldas,&nhills,&ncoord,&ntin,&nreg,ruta,&umbral,meanrain,posids,maskvector,slen(ruta));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("NN",capi_meanrain_tmp,capi_posids_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_posids_tmp == NULL) ... else of posids*/
  /* End of cleaning variable posids */
  }  /*if (capi_meanrain_tmp == NULL) ... else of meanrain*/
  /* End of cleaning variable meanrain */
  } /*CHECKSCALAR(shape(rain,1)==nreg)*/
  } /*if (f2py_success) of nreg*/
  /* End of cleaning variable nreg */
  if((PyObject *)capi_rain_tmp!=rain_capi) {
    Py_XDECREF(capi_rain_tmp); }
  }  /*if (capi_rain_tmp == NULL) ... else of rain*/
  /* End of cleaning variable rain */
  if((PyObject *)capi_maskvector_tmp!=maskvector_capi) {
    Py_XDECREF(capi_maskvector_tmp); }
  }  /*if (capi_maskvector_tmp == NULL) ... else of maskvector*/
  /* End of cleaning variable maskvector */
  if((PyObject *)capi_tin_perte_tmp!=tin_perte_capi) {
    Py_XDECREF(capi_tin_perte_tmp); }
  }  /*if (capi_tin_perte_tmp == NULL) ... else of tin_perte*/
  /* End of cleaning variable tin_perte */
  } /*CHECKSCALAR(shape(tin,1)==ntin)*/
  } /*if (f2py_success) of ntin*/
  /* End of cleaning variable ntin */
  } /*CHECKSCALAR(shape(coord,1)==ncoord)*/
  } /*if (f2py_success) of ncoord*/
  /* End of cleaning variable ncoord */
  } /*CHECKSCALAR(shape(xy_basin,1)==nceldas)*/
  } /*if (f2py_success) of nceldas*/
  /* End of cleaning variable nceldas */
    STRINGFREE(ruta);
  }  /*if (f2py_success) of ruta*/
  /* End of cleaning variable ruta */
  } /*if (f2py_success) of umbral*/
  /* End of cleaning variable umbral */
  if((PyObject *)capi_coord_tmp!=coord_capi) {
    Py_XDECREF(capi_coord_tmp); }
  }  /*if (capi_coord_tmp == NULL) ... else of coord*/
  /* End of cleaning variable coord */
  if((PyObject *)capi_xy_basin_tmp!=xy_basin_capi) {
    Py_XDECREF(capi_xy_basin_tmp); }
  }  /*if (capi_xy_basin_tmp == NULL) ... else of xy_basin*/
  /* End of cleaning variable xy_basin */
  if((PyObject *)capi_tin_tmp!=tin_capi) {
    Py_XDECREF(capi_tin_tmp); }
  }  /*if (capi_tin_tmp == NULL) ... else of tin*/
  /* End of cleaning variable tin */
  } /*if (f2py_success) of nhills*/
  /* End of cleaning variable nhills */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of rain_mit ******************************/

/********************************** rain_idw **********************************/
static char doc_f2py_rout_models_models_rain_idw[] = "\
meanrain,posids = rain_idw(xy_basin,coord,rain,pp,nhills,ruta,umbral,maskvector,[nceldas,ncoord,nreg])\n\nWrapper for ``rain_idw``.\
\n\nParameters\n----------\n"
"xy_basin : input rank-2 array('f') with bounds (2,nceldas)\n"
"coord : input rank-2 array('f') with bounds (2,ncoord)\n"
"rain : input rank-2 array('f') with bounds (ncoord,nreg)\n"
"pp : input float\n"
"nhills : input int\n"
"ruta : input string(len=255)\n"
"umbral : input float\n"
"maskvector : input rank-1 array('i') with bounds (nceldas)\n"
"\nOther Parameters\n----------------\n"
"nceldas : input int, optional\n    Default: shape(xy_basin,1)\n"
"ncoord : input int, optional\n    Default: shape(coord,1)\n"
"nreg : input int, optional\n    Default: shape(rain,1)\n"
"\nReturns\n-------\n"
"meanrain : rank-1 array('f') with bounds (nreg)\n"
"posids : rank-1 array('i') with bounds (nreg)";
/*  */
static PyObject *f2py_rout_models_models_rain_idw(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,float*,float*,int*,int*,int*,int*,string,float*,float*,int*,int*,size_t)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float *xy_basin = NULL;
  npy_intp xy_basin_Dims[2] = {-1, -1};
  const int xy_basin_Rank = 2;
  PyArrayObject *capi_xy_basin_tmp = NULL;
  int capi_xy_basin_intent = 0;
  PyObject *xy_basin_capi = Py_None;
  float *coord = NULL;
  npy_intp coord_Dims[2] = {-1, -1};
  const int coord_Rank = 2;
  PyArrayObject *capi_coord_tmp = NULL;
  int capi_coord_intent = 0;
  PyObject *coord_capi = Py_None;
  float *rain = NULL;
  npy_intp rain_Dims[2] = {-1, -1};
  const int rain_Rank = 2;
  PyArrayObject *capi_rain_tmp = NULL;
  int capi_rain_intent = 0;
  PyObject *rain_capi = Py_None;
  float pp = 0;
  PyObject *pp_capi = Py_None;
  int nceldas = 0;
  PyObject *nceldas_capi = Py_None;
  int ncoord = 0;
  PyObject *ncoord_capi = Py_None;
  int nreg = 0;
  PyObject *nreg_capi = Py_None;
  int nhills = 0;
  PyObject *nhills_capi = Py_None;
  string ruta = NULL;
  int slen(ruta);
  PyObject *ruta_capi = Py_None;
  float umbral = 0;
  PyObject *umbral_capi = Py_None;
  float *meanrain = NULL;
  npy_intp meanrain_Dims[1] = {-1};
  const int meanrain_Rank = 1;
  PyArrayObject *capi_meanrain_tmp = NULL;
  int capi_meanrain_intent = 0;
  int *posids = NULL;
  npy_intp posids_Dims[1] = {-1};
  const int posids_Rank = 1;
  PyArrayObject *capi_posids_tmp = NULL;
  int capi_posids_intent = 0;
  int *maskvector = NULL;
  npy_intp maskvector_Dims[1] = {-1};
  const int maskvector_Rank = 1;
  PyArrayObject *capi_maskvector_tmp = NULL;
  int capi_maskvector_intent = 0;
  PyObject *maskvector_capi = Py_None;
  static char *capi_kwlist[] = {"xy_basin","coord","rain","pp","nhills","ruta","umbral","maskvector","nceldas","ncoord","nreg",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOOO|OOO:models.models.rain_idw",\
    capi_kwlist,&xy_basin_capi,&coord_capi,&rain_capi,&pp_capi,&nhills_capi,&ruta_capi,&umbral_capi,&maskvector_capi,&nceldas_capi,&ncoord_capi,&nreg_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable nhills */
    f2py_success = int_from_pyobj(&nhills,nhills_capi,"models.models.rain_idw() 5th argument (nhills) can't be converted to int");
  if (f2py_success) {
  /* Processing variable ruta */
  slen(ruta) = 255;
  f2py_success = string_from_pyobj(&ruta,&slen(ruta),"",ruta_capi,"string_from_pyobj failed in converting 6th argument `ruta' of models.models.rain_idw to C string");
  if (f2py_success) {
  /* Processing variable xy_basin */
  xy_basin_Dims[0]=2;
  capi_xy_basin_intent |= F2PY_INTENT_IN;
  capi_xy_basin_tmp = array_from_pyobj(NPY_FLOAT,xy_basin_Dims,xy_basin_Rank,capi_xy_basin_intent,xy_basin_capi);
  if (capi_xy_basin_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 1st argument `xy_basin' of models.models.rain_idw to C/Fortran array" );
  } else {
    xy_basin = (float *)(PyArray_DATA(capi_xy_basin_tmp));

  /* Processing variable coord */
  coord_Dims[0]=2;
  capi_coord_intent |= F2PY_INTENT_IN;
  capi_coord_tmp = array_from_pyobj(NPY_FLOAT,coord_Dims,coord_Rank,capi_coord_intent,coord_capi);
  if (capi_coord_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 2nd argument `coord' of models.models.rain_idw to C/Fortran array" );
  } else {
    coord = (float *)(PyArray_DATA(capi_coord_tmp));

  /* Processing variable pp */
    f2py_success = float_from_pyobj(&pp,pp_capi,"models.models.rain_idw() 4th argument (pp) can't be converted to float");
  if (f2py_success) {
  /* Processing variable umbral */
    f2py_success = float_from_pyobj(&umbral,umbral_capi,"models.models.rain_idw() 7th argument (umbral) can't be converted to float");
  if (f2py_success) {
  /* Processing variable nceldas */
  if (nceldas_capi == Py_None) nceldas = shape(xy_basin,1); else
    f2py_success = int_from_pyobj(&nceldas,nceldas_capi,"models.models.rain_idw() 1st keyword (nceldas) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(xy_basin,1)==nceldas,"shape(xy_basin,1)==nceldas","1st keyword nceldas","rain_idw:nceldas=%d",nceldas) {
  /* Processing variable ncoord */
  if (ncoord_capi == Py_None) ncoord = shape(coord,1); else
    f2py_success = int_from_pyobj(&ncoord,ncoord_capi,"models.models.rain_idw() 2nd keyword (ncoord) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(coord,1)==ncoord,"shape(coord,1)==ncoord","2nd keyword ncoord","rain_idw:ncoord=%d",ncoord) {
  /* Processing variable maskvector */
  maskvector_Dims[0]=nceldas;
  capi_maskvector_intent |= F2PY_INTENT_IN;
  capi_maskvector_tmp = array_from_pyobj(NPY_INT,maskvector_Dims,maskvector_Rank,capi_maskvector_intent,maskvector_capi);
  if (capi_maskvector_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 8th argument `maskvector' of models.models.rain_idw to C/Fortran array" );
  } else {
    maskvector = (int *)(PyArray_DATA(capi_maskvector_tmp));

  /* Processing variable rain */
  rain_Dims[0]=ncoord;
  capi_rain_intent |= F2PY_INTENT_IN;
  capi_rain_tmp = array_from_pyobj(NPY_FLOAT,rain_Dims,rain_Rank,capi_rain_intent,rain_capi);
  if (capi_rain_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 3rd argument `rain' of models.models.rain_idw to C/Fortran array" );
  } else {
    rain = (float *)(PyArray_DATA(capi_rain_tmp));

  /* Processing variable nreg */
  if (nreg_capi == Py_None) nreg = shape(rain,1); else
    f2py_success = int_from_pyobj(&nreg,nreg_capi,"models.models.rain_idw() 3rd keyword (nreg) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(rain,1)==nreg,"shape(rain,1)==nreg","3rd keyword nreg","rain_idw:nreg=%d",nreg) {
  /* Processing variable meanrain */
  meanrain_Dims[0]=nreg;
  capi_meanrain_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_meanrain_tmp = array_from_pyobj(NPY_FLOAT,meanrain_Dims,meanrain_Rank,capi_meanrain_intent,Py_None);
  if (capi_meanrain_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `meanrain' of models.models.rain_idw to C/Fortran array" );
  } else {
    meanrain = (float *)(PyArray_DATA(capi_meanrain_tmp));

  /* Processing variable posids */
  posids_Dims[0]=nreg;
  capi_posids_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_posids_tmp = array_from_pyobj(NPY_INT,posids_Dims,posids_Rank,capi_posids_intent,Py_None);
  if (capi_posids_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `posids' of models.models.rain_idw to C/Fortran array" );
  } else {
    posids = (int *)(PyArray_DATA(capi_posids_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(xy_basin,coord,rain,&pp,&nceldas,&ncoord,&nreg,&nhills,ruta,&umbral,meanrain,posids,maskvector,slen(ruta));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("NN",capi_meanrain_tmp,capi_posids_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_posids_tmp == NULL) ... else of posids*/
  /* End of cleaning variable posids */
  }  /*if (capi_meanrain_tmp == NULL) ... else of meanrain*/
  /* End of cleaning variable meanrain */
  } /*CHECKSCALAR(shape(rain,1)==nreg)*/
  } /*if (f2py_success) of nreg*/
  /* End of cleaning variable nreg */
  if((PyObject *)capi_rain_tmp!=rain_capi) {
    Py_XDECREF(capi_rain_tmp); }
  }  /*if (capi_rain_tmp == NULL) ... else of rain*/
  /* End of cleaning variable rain */
  if((PyObject *)capi_maskvector_tmp!=maskvector_capi) {
    Py_XDECREF(capi_maskvector_tmp); }
  }  /*if (capi_maskvector_tmp == NULL) ... else of maskvector*/
  /* End of cleaning variable maskvector */
  } /*CHECKSCALAR(shape(coord,1)==ncoord)*/
  } /*if (f2py_success) of ncoord*/
  /* End of cleaning variable ncoord */
  } /*CHECKSCALAR(shape(xy_basin,1)==nceldas)*/
  } /*if (f2py_success) of nceldas*/
  /* End of cleaning variable nceldas */
  } /*if (f2py_success) of umbral*/
  /* End of cleaning variable umbral */
  } /*if (f2py_success) of pp*/
  /* End of cleaning variable pp */
  if((PyObject *)capi_coord_tmp!=coord_capi) {
    Py_XDECREF(capi_coord_tmp); }
  }  /*if (capi_coord_tmp == NULL) ... else of coord*/
  /* End of cleaning variable coord */
  if((PyObject *)capi_xy_basin_tmp!=xy_basin_capi) {
    Py_XDECREF(capi_xy_basin_tmp); }
  }  /*if (capi_xy_basin_tmp == NULL) ... else of xy_basin*/
  /* End of cleaning variable xy_basin */
    STRINGFREE(ruta);
  }  /*if (f2py_success) of ruta*/
  /* End of cleaning variable ruta */
  } /*if (f2py_success) of nhills*/
  /* End of cleaning variable nhills */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of rain_idw ******************************/

/********************************* calc_speed *********************************/
static char doc_f2py_rout_models_models_calc_speed[] = "\
area = calc_speed(sm,coef,expo,elem_long,speed)\n\nWrapper for ``calc_speed``.\
\n\nParameters\n----------\n"
"sm : input float\n"
"coef : input float\n"
"expo : input float\n"
"elem_long : input float\n"
"speed : in/output rank-0 array(float,'f')\n"
"\nReturns\n-------\n"
"area : float";
/*  */
static PyObject *f2py_rout_models_models_calc_speed(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,float*,float*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float sm = 0;
  PyObject *sm_capi = Py_None;
  float coef = 0;
  PyObject *coef_capi = Py_None;
  float expo = 0;
  PyObject *expo_capi = Py_None;
  float elem_long = 0;
  PyObject *elem_long_capi = Py_None;
  float speed = 0;
  PyObject *speed_capi = Py_None;
  float area = 0;
  static char *capi_kwlist[] = {"sm","coef","expo","elem_long","speed",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO:models.models.calc_speed",\
    capi_kwlist,&sm_capi,&coef_capi,&expo_capi,&elem_long_capi,&speed_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable sm */
    f2py_success = float_from_pyobj(&sm,sm_capi,"models.models.calc_speed() 1st argument (sm) can't be converted to float");
  if (f2py_success) {
  /* Processing variable coef */
    f2py_success = float_from_pyobj(&coef,coef_capi,"models.models.calc_speed() 2nd argument (coef) can't be converted to float");
  if (f2py_success) {
  /* Processing variable expo */
    f2py_success = float_from_pyobj(&expo,expo_capi,"models.models.calc_speed() 3rd argument (expo) can't be converted to float");
  if (f2py_success) {
  /* Processing variable elem_long */
    f2py_success = float_from_pyobj(&elem_long,elem_long_capi,"models.models.calc_speed() 4th argument (elem_long) can't be converted to float");
  if (f2py_success) {
  /* Processing variable area */
  /* Processing variable speed */
    f2py_success = float_from_pyobj(&speed,speed_capi,"models.models.calc_speed() 5th argument (speed) can't be converted to float");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&sm,&coef,&expo,&elem_long,&speed,&area);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_float(speed_capi,&speed);
  if (f2py_success) {
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("f",area);
/*closepyobjfrom*/
  } /*if (f2py_success) of speed pyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of speed*/
  /* End of cleaning variable speed */
  /* End of cleaning variable area */
  } /*if (f2py_success) of elem_long*/
  /* End of cleaning variable elem_long */
  } /*if (f2py_success) of expo*/
  /* End of cleaning variable expo */
  } /*if (f2py_success) of coef*/
  /* End of cleaning variable coef */
  } /*if (f2py_success) of sm*/
  /* End of cleaning variable sm */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of calc_speed *****************************/

/******************************** sed_allocate ********************************/
static char doc_f2py_rout_models_models_sed_allocate[] = "\
sed_allocate(n_cel)\n\nWrapper for ``sed_allocate``.\
\n\nParameters\n----------\n"
"n_cel : input int";
/*  */
static PyObject *f2py_rout_models_models_sed_allocate(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int n_cel = 0;
  PyObject *n_cel_capi = Py_None;
  static char *capi_kwlist[] = {"n_cel",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:models.models.sed_allocate",\
    capi_kwlist,&n_cel_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n_cel */
    f2py_success = int_from_pyobj(&n_cel,n_cel_capi,"models.models.sed_allocate() 1st argument (n_cel) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&n_cel);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of n_cel*/
  /* End of cleaning variable n_cel */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of sed_allocate ****************************/

/******************************* sed_hillslope *******************************/
static char doc_f2py_rout_models_models_sed_hillslope[] = "\
sed_hillslope(alfa,v2,s2,so,celda,drena_id,tipo)\n\nWrapper for ``sed_hillslope``.\
\n\nParameters\n----------\n"
"alfa : input float\n"
"v2 : input float\n"
"s2 : input float\n"
"so : input float\n"
"celda : input int\n"
"drena_id : input int\n"
"tipo : input int";
/*  */
static PyObject *f2py_rout_models_models_sed_hillslope(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,float*,float*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float alfa = 0;
  PyObject *alfa_capi = Py_None;
  float v2 = 0;
  PyObject *v2_capi = Py_None;
  float s2 = 0;
  PyObject *s2_capi = Py_None;
  float so = 0;
  PyObject *so_capi = Py_None;
  int celda = 0;
  PyObject *celda_capi = Py_None;
  int drena_id = 0;
  PyObject *drena_id_capi = Py_None;
  int tipo = 0;
  PyObject *tipo_capi = Py_None;
  static char *capi_kwlist[] = {"alfa","v2","s2","so","celda","drena_id","tipo",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOO:models.models.sed_hillslope",\
    capi_kwlist,&alfa_capi,&v2_capi,&s2_capi,&so_capi,&celda_capi,&drena_id_capi,&tipo_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable v2 */
    f2py_success = float_from_pyobj(&v2,v2_capi,"models.models.sed_hillslope() 2nd argument (v2) can't be converted to float");
  if (f2py_success) {
  /* Processing variable so */
    f2py_success = float_from_pyobj(&so,so_capi,"models.models.sed_hillslope() 4th argument (so) can't be converted to float");
  if (f2py_success) {
  /* Processing variable alfa */
    f2py_success = float_from_pyobj(&alfa,alfa_capi,"models.models.sed_hillslope() 1st argument (alfa) can't be converted to float");
  if (f2py_success) {
  /* Processing variable s2 */
    f2py_success = float_from_pyobj(&s2,s2_capi,"models.models.sed_hillslope() 3rd argument (s2) can't be converted to float");
  if (f2py_success) {
  /* Processing variable celda */
    f2py_success = int_from_pyobj(&celda,celda_capi,"models.models.sed_hillslope() 5th argument (celda) can't be converted to int");
  if (f2py_success) {
  /* Processing variable drena_id */
    f2py_success = int_from_pyobj(&drena_id,drena_id_capi,"models.models.sed_hillslope() 6th argument (drena_id) can't be converted to int");
  if (f2py_success) {
  /* Processing variable tipo */
    f2py_success = int_from_pyobj(&tipo,tipo_capi,"models.models.sed_hillslope() 7th argument (tipo) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&alfa,&v2,&s2,&so,&celda,&drena_id,&tipo);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of tipo*/
  /* End of cleaning variable tipo */
  } /*if (f2py_success) of drena_id*/
  /* End of cleaning variable drena_id */
  } /*if (f2py_success) of celda*/
  /* End of cleaning variable celda */
  } /*if (f2py_success) of s2*/
  /* End of cleaning variable s2 */
  } /*if (f2py_success) of alfa*/
  /* End of cleaning variable alfa */
  } /*if (f2py_success) of so*/
  /* End of cleaning variable so */
  } /*if (f2py_success) of v2*/
  /* End of cleaning variable v2 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of sed_hillslope ****************************/

/******************************** sed_channel ********************************/
static char doc_f2py_rout_models_models_sed_channel[] = "\
volsal = sed_channel(s5,v5,q5,so,area_sec,celda,drena_id)\n\nWrapper for ``sed_channel``.\
\n\nParameters\n----------\n"
"s5 : input float\n"
"v5 : input float\n"
"q5 : input float\n"
"so : input float\n"
"area_sec : input float\n"
"celda : input int\n"
"drena_id : input int\n"
"\nReturns\n-------\n"
"volsal : rank-1 array('f') with bounds (3)";
/*  */
static PyObject *f2py_rout_models_models_sed_channel(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,float*,float*,float*,int*,int*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float s5 = 0;
  PyObject *s5_capi = Py_None;
  float v5 = 0;
  PyObject *v5_capi = Py_None;
  float q5 = 0;
  PyObject *q5_capi = Py_None;
  float so = 0;
  PyObject *so_capi = Py_None;
  float area_sec = 0;
  PyObject *area_sec_capi = Py_None;
  int celda = 0;
  PyObject *celda_capi = Py_None;
  int drena_id = 0;
  PyObject *drena_id_capi = Py_None;
  float *volsal = NULL;
  npy_intp volsal_Dims[1] = {-1};
  const int volsal_Rank = 1;
  PyArrayObject *capi_volsal_tmp = NULL;
  int capi_volsal_intent = 0;
  static char *capi_kwlist[] = {"s5","v5","q5","so","area_sec","celda","drena_id",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOO:models.models.sed_channel",\
    capi_kwlist,&s5_capi,&v5_capi,&q5_capi,&so_capi,&area_sec_capi,&celda_capi,&drena_id_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable s5 */
    f2py_success = float_from_pyobj(&s5,s5_capi,"models.models.sed_channel() 1st argument (s5) can't be converted to float");
  if (f2py_success) {
  /* Processing variable v5 */
    f2py_success = float_from_pyobj(&v5,v5_capi,"models.models.sed_channel() 2nd argument (v5) can't be converted to float");
  if (f2py_success) {
  /* Processing variable so */
    f2py_success = float_from_pyobj(&so,so_capi,"models.models.sed_channel() 4th argument (so) can't be converted to float");
  if (f2py_success) {
  /* Processing variable area_sec */
    f2py_success = float_from_pyobj(&area_sec,area_sec_capi,"models.models.sed_channel() 5th argument (area_sec) can't be converted to float");
  if (f2py_success) {
  /* Processing variable q5 */
    f2py_success = float_from_pyobj(&q5,q5_capi,"models.models.sed_channel() 3rd argument (q5) can't be converted to float");
  if (f2py_success) {
  /* Processing variable celda */
    f2py_success = int_from_pyobj(&celda,celda_capi,"models.models.sed_channel() 6th argument (celda) can't be converted to int");
  if (f2py_success) {
  /* Processing variable drena_id */
    f2py_success = int_from_pyobj(&drena_id,drena_id_capi,"models.models.sed_channel() 7th argument (drena_id) can't be converted to int");
  if (f2py_success) {
  /* Processing variable volsal */
  volsal_Dims[0]=3;
  capi_volsal_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_volsal_tmp = array_from_pyobj(NPY_FLOAT,volsal_Dims,volsal_Rank,capi_volsal_intent,Py_None);
  if (capi_volsal_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `volsal' of models.models.sed_channel to C/Fortran array" );
  } else {
    volsal = (float *)(PyArray_DATA(capi_volsal_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&s5,&v5,&q5,&so,&area_sec,&celda,&drena_id,volsal);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_volsal_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_volsal_tmp == NULL) ... else of volsal*/
  /* End of cleaning variable volsal */
  } /*if (f2py_success) of drena_id*/
  /* End of cleaning variable drena_id */
  } /*if (f2py_success) of celda*/
  /* End of cleaning variable celda */
  } /*if (f2py_success) of q5*/
  /* End of cleaning variable q5 */
  } /*if (f2py_success) of area_sec*/
  /* End of cleaning variable area_sec */
  } /*if (f2py_success) of so*/
  /* End of cleaning variable so */
  } /*if (f2py_success) of v5*/
  /* End of cleaning variable v5 */
  } /*if (f2py_success) of s5*/
  /* End of cleaning variable s5 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of sed_channel *****************************/

/******************************* slide_allocate *******************************/
static char doc_f2py_rout_models_models_slide_allocate[] = "\
slide_allocate(n_cel,n_reg)\n\nWrapper for ``slide_allocate``.\
\n\nParameters\n----------\n"
"n_cel : input int\n"
"n_reg : input int";
/*  */
static PyObject *f2py_rout_models_models_slide_allocate(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int n_cel = 0;
  PyObject *n_cel_capi = Py_None;
  int n_reg = 0;
  PyObject *n_reg_capi = Py_None;
  static char *capi_kwlist[] = {"n_cel","n_reg",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:models.models.slide_allocate",\
    capi_kwlist,&n_cel_capi,&n_reg_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n_cel */
    f2py_success = int_from_pyobj(&n_cel,n_cel_capi,"models.models.slide_allocate() 1st argument (n_cel) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n_reg */
    f2py_success = int_from_pyobj(&n_reg,n_reg_capi,"models.models.slide_allocate() 2nd argument (n_reg) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&n_cel,&n_reg);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of n_reg*/
  /* End of cleaning variable n_reg */
  } /*if (f2py_success) of n_cel*/
  /* End of cleaning variable n_cel */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of slide_allocate ***************************/

/****************************** slide_ocurrence ******************************/
static char doc_f2py_rout_models_models_slide_ocurrence[] = "\
slide_ocurrence(n_cel,timestep,cell,storaget3,maxstot3)\n\nWrapper for ``slide_ocurrence``.\
\n\nParameters\n----------\n"
"n_cel : input int\n"
"timestep : input int\n"
"cell : input int\n"
"storaget3 : input float\n"
"maxstot3 : input float";
/*  */
static PyObject *f2py_rout_models_models_slide_ocurrence(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int n_cel = 0;
  PyObject *n_cel_capi = Py_None;
  int timestep = 0;
  PyObject *timestep_capi = Py_None;
  int cell = 0;
  PyObject *cell_capi = Py_None;
  float storaget3 = 0;
  PyObject *storaget3_capi = Py_None;
  float maxstot3 = 0;
  PyObject *maxstot3_capi = Py_None;
  static char *capi_kwlist[] = {"n_cel","timestep","cell","storaget3","maxstot3",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO:models.models.slide_ocurrence",\
    capi_kwlist,&n_cel_capi,&timestep_capi,&cell_capi,&storaget3_capi,&maxstot3_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable storaget3 */
    f2py_success = float_from_pyobj(&storaget3,storaget3_capi,"models.models.slide_ocurrence() 4th argument (storaget3) can't be converted to float");
  if (f2py_success) {
  /* Processing variable maxstot3 */
    f2py_success = float_from_pyobj(&maxstot3,maxstot3_capi,"models.models.slide_ocurrence() 5th argument (maxstot3) can't be converted to float");
  if (f2py_success) {
  /* Processing variable cell */
    f2py_success = int_from_pyobj(&cell,cell_capi,"models.models.slide_ocurrence() 3rd argument (cell) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n_cel */
    f2py_success = int_from_pyobj(&n_cel,n_cel_capi,"models.models.slide_ocurrence() 1st argument (n_cel) can't be converted to int");
  if (f2py_success) {
  /* Processing variable timestep */
    f2py_success = int_from_pyobj(&timestep,timestep_capi,"models.models.slide_ocurrence() 2nd argument (timestep) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&n_cel,&timestep,&cell,&storaget3,&maxstot3);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of timestep*/
  /* End of cleaning variable timestep */
  } /*if (f2py_success) of n_cel*/
  /* End of cleaning variable n_cel */
  } /*if (f2py_success) of cell*/
  /* End of cleaning variable cell */
  } /*if (f2py_success) of maxstot3*/
  /* End of cleaning variable maxstot3 */
  } /*if (f2py_success) of storaget3*/
  /* End of cleaning variable storaget3 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of slide_ocurrence ***************************/

/***************************** slide_hill2gullie *****************************/
static char doc_f2py_rout_models_models_slide_hill2gullie[] = "\
slide_hill2gullie(n_cel,cell,timest)\n\nWrapper for ``slide_hill2gullie``.\
\n\nParameters\n----------\n"
"n_cel : input int\n"
"cell : input int\n"
"timest : input int";
/*  */
static PyObject *f2py_rout_models_models_slide_hill2gullie(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int n_cel = 0;
  PyObject *n_cel_capi = Py_None;
  int cell = 0;
  PyObject *cell_capi = Py_None;
  int timest = 0;
  PyObject *timest_capi = Py_None;
  static char *capi_kwlist[] = {"n_cel","cell","timest",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:models.models.slide_hill2gullie",\
    capi_kwlist,&n_cel_capi,&cell_capi,&timest_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable cell */
    f2py_success = int_from_pyobj(&cell,cell_capi,"models.models.slide_hill2gullie() 2nd argument (cell) can't be converted to int");
  if (f2py_success) {
  /* Processing variable n_cel */
    f2py_success = int_from_pyobj(&n_cel,n_cel_capi,"models.models.slide_hill2gullie() 1st argument (n_cel) can't be converted to int");
  if (f2py_success) {
  /* Processing variable timest */
    f2py_success = int_from_pyobj(&timest,timest_capi,"models.models.slide_hill2gullie() 3rd argument (timest) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&n_cel,&cell,&timest);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of timest*/
  /* End of cleaning variable timest */
  } /*if (f2py_success) of n_cel*/
  /* End of cleaning variable n_cel */
  } /*if (f2py_success) of cell*/
  /* End of cleaning variable cell */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of slide_hill2gullie **************************/

/******************************* flood_allocate *******************************/
static char doc_f2py_rout_models_models_flood_allocate[] = "\
flood_allocate(n_cel)\n\nWrapper for ``flood_allocate``.\
\n\nParameters\n----------\n"
"n_cel : input int";
/*  */
static PyObject *f2py_rout_models_models_flood_allocate(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int n_cel = 0;
  PyObject *n_cel_capi = Py_None;
  static char *capi_kwlist[] = {"n_cel",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:models.models.flood_allocate",\
    capi_kwlist,&n_cel_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n_cel */
    f2py_success = int_from_pyobj(&n_cel,n_cel_capi,"models.models.flood_allocate() 1st argument (n_cel) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&n_cel);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of n_cel*/
  /* End of cleaning variable n_cel */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of flood_allocate ***************************/

/******************************** flood_params ********************************/
static char doc_f2py_rout_models_models_flood_params[] = "\
flood_params(celda)\n\nWrapper for ``flood_params``.\
\n\nParameters\n----------\n"
"celda : input int";
/*  */
static PyObject *f2py_rout_models_models_flood_params(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int celda = 0;
  PyObject *celda_capi = Py_None;
  static char *capi_kwlist[] = {"celda",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:models.models.flood_params",\
    capi_kwlist,&celda_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable celda */
    f2py_success = int_from_pyobj(&celda,celda_capi,"models.models.flood_params() 1st argument (celda) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&celda);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of celda*/
  /* End of cleaning variable celda */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of flood_params ****************************/

/****************************** flood_find_hdiff ******************************/
static char doc_f2py_rout_models_models_flood_find_hdiff[] = "\
flood_find_hdiff(celda)\n\nWrapper for ``flood_find_hdiff``.\
\n\nParameters\n----------\n"
"celda : input int";
/*  */
static PyObject *f2py_rout_models_models_flood_find_hdiff(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int celda = 0;
  PyObject *celda_capi = Py_None;
  static char *capi_kwlist[] = {"celda",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:models.models.flood_find_hdiff",\
    capi_kwlist,&celda_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable celda */
    f2py_success = int_from_pyobj(&celda,celda_capi,"models.models.flood_find_hdiff() 1st argument (celda) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&celda);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of celda*/
  /* End of cleaning variable celda */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of flood_find_hdiff **************************/

/***************************** flood_debris_flow *****************************/
static char doc_f2py_rout_models_models_flood_debris_flow[] = "\
areas,dif = flood_debris_flow(celda)\n\nWrapper for ``flood_debris_flow``.\
\n\nParameters\n----------\n"
"celda : input int\n"
"\nReturns\n-------\n"
"areas : float\n"
"dif : float";
/*  */
static PyObject *f2py_rout_models_models_flood_debris_flow(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int celda = 0;
  PyObject *celda_capi = Py_None;
  float areas = 0;
  float dif = 0;
  static char *capi_kwlist[] = {"celda",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:models.models.flood_debris_flow",\
    capi_kwlist,&celda_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable celda */
    f2py_success = int_from_pyobj(&celda,celda_capi,"models.models.flood_debris_flow() 1st argument (celda) can't be converted to int");
  if (f2py_success) {
  /* Processing variable areas */
  /* Processing variable dif */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&celda,&areas,&dif);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("ff",areas,dif);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable dif */
  /* End of cleaning variable areas */
  } /*if (f2py_success) of celda*/
  /* End of cleaning variable celda */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of flood_debris_flow **************************/

/***************************** flood_debris_flow2 *****************************/
static char doc_f2py_rout_models_models_flood_debris_flow2[] = "\
areas,dif = flood_debris_flow2(celda)\n\nWrapper for ``flood_debris_flow2``.\
\n\nParameters\n----------\n"
"celda : input int\n"
"\nReturns\n-------\n"
"areas : float\n"
"dif : float";
/*  */
static PyObject *f2py_rout_models_models_flood_debris_flow2(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int celda = 0;
  PyObject *celda_capi = Py_None;
  float areas = 0;
  float dif = 0;
  static char *capi_kwlist[] = {"celda",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:models.models.flood_debris_flow2",\
    capi_kwlist,&celda_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable celda */
    f2py_success = int_from_pyobj(&celda,celda_capi,"models.models.flood_debris_flow2() 1st argument (celda) can't be converted to int");
  if (f2py_success) {
  /* Processing variable areas */
  /* Processing variable dif */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&celda,&areas,&dif);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("ff",areas,dif);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable dif */
  /* End of cleaning variable areas */
  } /*if (f2py_success) of celda*/
  /* End of cleaning variable celda */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of flood_debris_flow2 *************************/

/************************ basin_subbasin_map2subbasin ************************/
static char doc_f2py_rout_models_models_basin_subbasin_map2subbasin[] = "\
subbasin_sum = basin_subbasin_map2subbasin(sub_pert,basin_var,n_nodos,sum_mean,[nceldas,cauce])\n\nWrapper for ``basin_subbasin_map2subbasin``.\
\n\nParameters\n----------\n"
"sub_pert : input rank-1 array('i') with bounds (nceldas)\n"
"basin_var : input rank-1 array('f') with bounds (nceldas)\n"
"n_nodos : input int\n"
"sum_mean : input int\n"
"\nOther Parameters\n----------------\n"
"nceldas : input int, optional\n    Default: len(sub_pert)\n"
"cauce : input rank-1 array('i') with bounds (nceldas)\n"
"\nReturns\n-------\n"
"subbasin_sum : rank-1 array('f') with bounds (n_nodos)";
/*  */
static PyObject *f2py_rout_models_models_basin_subbasin_map2subbasin(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,float*,float*,int*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int *sub_pert = NULL;
  npy_intp sub_pert_Dims[1] = {-1};
  const int sub_pert_Rank = 1;
  PyArrayObject *capi_sub_pert_tmp = NULL;
  int capi_sub_pert_intent = 0;
  PyObject *sub_pert_capi = Py_None;
  float *basin_var = NULL;
  npy_intp basin_var_Dims[1] = {-1};
  const int basin_var_Rank = 1;
  PyArrayObject *capi_basin_var_tmp = NULL;
  int capi_basin_var_intent = 0;
  PyObject *basin_var_capi = Py_None;
  float *subbasin_sum = NULL;
  npy_intp subbasin_sum_Dims[1] = {-1};
  const int subbasin_sum_Rank = 1;
  PyArrayObject *capi_subbasin_sum_tmp = NULL;
  int capi_subbasin_sum_intent = 0;
  int n_nodos = 0;
  PyObject *n_nodos_capi = Py_None;
  int nceldas = 0;
  PyObject *nceldas_capi = Py_None;
  int *cauce = NULL;
  npy_intp cauce_Dims[1] = {-1};
  const int cauce_Rank = 1;
  PyArrayObject *capi_cauce_tmp = NULL;
  int capi_cauce_intent = 0;
  PyObject *cauce_capi = Py_None;
  int sum_mean = 0;
  PyObject *sum_mean_capi = Py_None;
  static char *capi_kwlist[] = {"sub_pert","basin_var","n_nodos","sum_mean","nceldas","cauce",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO|OO:models.models.basin_subbasin_map2subbasin",\
    capi_kwlist,&sub_pert_capi,&basin_var_capi,&n_nodos_capi,&sum_mean_capi,&nceldas_capi,&cauce_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable n_nodos */
    f2py_success = int_from_pyobj(&n_nodos,n_nodos_capi,"models.models.basin_subbasin_map2subbasin() 3rd argument (n_nodos) can't be converted to int");
  if (f2py_success) {
  /* Processing variable sum_mean */
    f2py_success = int_from_pyobj(&sum_mean,sum_mean_capi,"models.models.basin_subbasin_map2subbasin() 4th argument (sum_mean) can't be converted to int");
  if (f2py_success) {
  /* Processing variable sub_pert */
  ;
  capi_sub_pert_intent |= F2PY_INTENT_IN;
  capi_sub_pert_tmp = array_from_pyobj(NPY_INT,sub_pert_Dims,sub_pert_Rank,capi_sub_pert_intent,sub_pert_capi);
  if (capi_sub_pert_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 1st argument `sub_pert' of models.models.basin_subbasin_map2subbasin to C/Fortran array" );
  } else {
    sub_pert = (int *)(PyArray_DATA(capi_sub_pert_tmp));

  /* Processing variable nceldas */
  if (nceldas_capi == Py_None) nceldas = len(sub_pert); else
    f2py_success = int_from_pyobj(&nceldas,nceldas_capi,"models.models.basin_subbasin_map2subbasin() 1st keyword (nceldas) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(sub_pert)>=nceldas,"len(sub_pert)>=nceldas","1st keyword nceldas","basin_subbasin_map2subbasin:nceldas=%d",nceldas) {
  /* Processing variable basin_var */
  basin_var_Dims[0]=nceldas;
  capi_basin_var_intent |= F2PY_INTENT_IN;
  capi_basin_var_tmp = array_from_pyobj(NPY_FLOAT,basin_var_Dims,basin_var_Rank,capi_basin_var_intent,basin_var_capi);
  if (capi_basin_var_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 2nd argument `basin_var' of models.models.basin_subbasin_map2subbasin to C/Fortran array" );
  } else {
    basin_var = (float *)(PyArray_DATA(capi_basin_var_tmp));

  /* Processing variable cauce */
  cauce_Dims[0]=nceldas;
  capi_cauce_intent |= F2PY_INTENT_IN|F2PY_OPTIONAL;
  capi_cauce_tmp = array_from_pyobj(NPY_INT,cauce_Dims,cauce_Rank,capi_cauce_intent,cauce_capi);
  if (capi_cauce_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 2nd keyword `cauce' of models.models.basin_subbasin_map2subbasin to C/Fortran array" );
  } else {
    cauce = (int *)(PyArray_DATA(capi_cauce_tmp));

  /* Processing variable subbasin_sum */
  subbasin_sum_Dims[0]=n_nodos;
  capi_subbasin_sum_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_subbasin_sum_tmp = array_from_pyobj(NPY_FLOAT,subbasin_sum_Dims,subbasin_sum_Rank,capi_subbasin_sum_intent,Py_None);
  if (capi_subbasin_sum_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting hidden `subbasin_sum' of models.models.basin_subbasin_map2subbasin to C/Fortran array" );
  } else {
    subbasin_sum = (float *)(PyArray_DATA(capi_subbasin_sum_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(sub_pert,basin_var,subbasin_sum,&n_nodos,&nceldas,cauce,&sum_mean);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_subbasin_sum_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_subbasin_sum_tmp == NULL) ... else of subbasin_sum*/
  /* End of cleaning variable subbasin_sum */
  if((PyObject *)capi_cauce_tmp!=cauce_capi) {
    Py_XDECREF(capi_cauce_tmp); }
  }  /*if (capi_cauce_tmp == NULL) ... else of cauce*/
  /* End of cleaning variable cauce */
  if((PyObject *)capi_basin_var_tmp!=basin_var_capi) {
    Py_XDECREF(capi_basin_var_tmp); }
  }  /*if (capi_basin_var_tmp == NULL) ... else of basin_var*/
  /* End of cleaning variable basin_var */
  } /*CHECKSCALAR(len(sub_pert)>=nceldas)*/
  } /*if (f2py_success) of nceldas*/
  /* End of cleaning variable nceldas */
  if((PyObject *)capi_sub_pert_tmp!=sub_pert_capi) {
    Py_XDECREF(capi_sub_pert_tmp); }
  }  /*if (capi_sub_pert_tmp == NULL) ... else of sub_pert*/
  /* End of cleaning variable sub_pert */
  } /*if (f2py_success) of sum_mean*/
  /* End of cleaning variable sum_mean */
  } /*if (f2py_success) of n_nodos*/
  /* End of cleaning variable n_nodos */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/********************* end of basin_subbasin_map2subbasin *********************/

/*********************************** qsortc ***********************************/
static char doc_f2py_rout_models_models_qsortc[] = "\
qsortc(a)\n\nWrapper for ``qsortc``.\
\n\nParameters\n----------\n"
"a : in/output rank-1 array('f') with bounds (f2py_a_d0)";
/* #declfortranroutine# */
static PyObject *f2py_rout_models_models_qsortc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float *a = NULL;
  npy_intp a_Dims[1] = {-1};
  const int a_Rank = 1;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  int f2py_a_d0 = 0;
  static char *capi_kwlist[] = {"a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:models.models.qsortc",\
    capi_kwlist,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_INOUT;
  capi_a_tmp = array_from_pyobj(NPY_FLOAT,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 1st argument `a' of models.models.qsortc to C/Fortran array" );
  } else {
    a = (float *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(a,&f2py_a_d0);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d0 */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of qsortc *******************************/

/********************************* partition *********************************/
static char doc_f2py_rout_models_models_partition[] = "\
marker = partition(a)\n\nWrapper for ``partition``.\
\n\nParameters\n----------\n"
"a : in/output rank-1 array('f') with bounds (f2py_a_d0)\n"
"\nReturns\n-------\n"
"marker : int";
/* #declfortranroutine# */
static PyObject *f2py_rout_models_models_partition(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float *a = NULL;
  npy_intp a_Dims[1] = {-1};
  const int a_Rank = 1;
  PyArrayObject *capi_a_tmp = NULL;
  int capi_a_intent = 0;
  PyObject *a_capi = Py_None;
  int marker = 0;
  int f2py_a_d0 = 0;
  static char *capi_kwlist[] = {"a",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:models.models.partition",\
    capi_kwlist,&a_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable a */
  ;
  capi_a_intent |= F2PY_INTENT_INOUT;
  capi_a_tmp = array_from_pyobj(NPY_FLOAT,a_Dims,a_Rank,capi_a_intent,a_capi);
  if (capi_a_tmp == NULL) {
    if (!PyErr_Occurred())
      PyErr_SetString(models_error,"failed in converting 1st argument `a' of models.models.partition to C/Fortran array" );
  } else {
    a = (float *)(PyArray_DATA(capi_a_tmp));

  /* Processing variable marker */
  /* Processing variable f2py_a_d0 */
  f2py_a_d0 = shape(a, 0);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(a,&marker,&f2py_a_d0);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("i",marker);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_a_d0 */
  /* End of cleaning variable marker */
  if((PyObject *)capi_a_tmp!=a_capi) {
    Py_XDECREF(capi_a_tmp); }
  }  /*if (capi_a_tmp == NULL) ... else of a*/
  /* End of cleaning variable a */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of partition ******************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/

static FortranDataDef f2py_models_def[] = {
  {"xll",0,{{-1}},NPY_FLOAT},
  {"yll",0,{{-1}},NPY_FLOAT},
  {"nodata",0,{{-1}},NPY_FLOAT},
  {"dx",0,{{-1}},NPY_FLOAT},
  {"dxp",0,{{-1}},NPY_FLOAT},
  {"ncols",0,{{-1}},NPY_INT},
  {"nrows",0,{{-1}},NPY_INT},
  {"nceldas",0,{{-1}},NPY_INT},
  {"verbose",0,{{-1}},NPY_INT},
  {"idevento",1,{{-1}},NPY_INT},
  {"posevento",1,{{-1}},NPY_INT},
  {"posconv",1,{{-1}},NPY_INT},
  {"posstra",1,{{-1}},NPY_INT},
  {"rute_speed",1,{{500}},NPY_STRING},
  {"rute_storage",1,{{500}},NPY_STRING},
  {"drena",2,{{-1,-1}},NPY_INT},
  {"unit_type",2,{{-1,-1}},NPY_INT},
  {"hill_long",2,{{-1,-1}},NPY_FLOAT},
  {"hill_slope",2,{{-1,-1}},NPY_FLOAT},
  {"stream_long",2,{{-1,-1}},NPY_FLOAT},
  {"stream_slope",2,{{-1,-1}},NPY_FLOAT},
  {"stream_width",2,{{-1,-1}},NPY_FLOAT},
  {"elem_area",2,{{-1,-1}},NPY_FLOAT},
  {"v_coef",2,{{-1,-1}},NPY_FLOAT},
  {"v_exp",2,{{-1,-1}},NPY_FLOAT},
  {"h_coef",2,{{-1,-1}},NPY_FLOAT},
  {"h_exp",2,{{-1,-1}},NPY_FLOAT},
  {"max_capilar",2,{{-1,-1}},NPY_FLOAT},
  {"max_gravita",2,{{-1,-1}},NPY_FLOAT},
  {"max_aquifer",2,{{-1,-1}},NPY_FLOAT},
  {"retorned",2,{{-1,-1}},NPY_FLOAT},
  {"evpserie",1,{{-1}},NPY_FLOAT},
  {"retorno_gr",0,{{-1}},NPY_FLOAT},
  {"retorno_aq",0,{{-1}},NPY_FLOAT},
  {"dt",0,{{-1}},NPY_FLOAT},
  {"rain_first_point",0,{{-1}},NPY_INT},
  {"sim_sediments",0,{{-1}},NPY_INT},
  {"sim_slides",0,{{-1}},NPY_INT},
  {"sim_floods",0,{{-1}},NPY_INT},
  {"save_storage",0,{{-1}},NPY_INT},
  {"save_speed",0,{{-1}},NPY_INT},
  {"save_retorno",0,{{-1}},NPY_INT},
  {"save_vfluxes",0,{{-1}},NPY_INT},
  {"save_rc",0,{{-1}},NPY_INT},
  {"show_storage",0,{{-1}},NPY_INT},
  {"show_speed",0,{{-1}},NPY_INT},
  {"show_mean_speed",0,{{-1}},NPY_INT},
  {"show_mean_retorno",0,{{-1}},NPY_INT},
  {"show_area",0,{{-1}},NPY_INT},
  {"separate_fluxes",0,{{-1}},NPY_INT},
  {"separate_rain",0,{{-1}},NPY_INT},
  {"speed_type",1,{{3}},NPY_INT},
  {"control",2,{{-1,-1}},NPY_INT},
  {"control_h",2,{{-1,-1}},NPY_INT},
  {"guarda_cond",1,{{-1}},NPY_INT},
  {"guarda_vfluxes",1,{{-1}},NPY_INT},
  {"calc_niter",0,{{-1}},NPY_INT},
  {"storage",2,{{-1,-1}},NPY_FLOAT},
  {"storage_constant",0,{{-1}},NPY_FLOAT},
  {"speed_map",2,{{-1,-1}},NPY_FLOAT},
  {"mean_rain",2,{{-1,-1}},NPY_FLOAT},
  {"acum_rain",2,{{-1,-1}},NPY_FLOAT},
  {"fluxes",2,{{-1,-1}},NPY_FLOAT},
  {"storage_conv",2,{{-1,-1}},NPY_FLOAT},
  {"storage_stra",2,{{-1,-1}},NPY_FLOAT},
  {"mean_storage",2,{{-1,-1}},NPY_FLOAT},
  {"mean_speed",2,{{-1,-1}},NPY_FLOAT},
  {"mean_retorno",1,{{-1}},NPY_FLOAT},
  {"mean_vfluxes",2,{{-1,-1}},NPY_FLOAT},
  {"vfluxes",2,{{-1,-1}},NPY_FLOAT},
  {"rc_coef",2,{{-1,-1}},NPY_FLOAT},
  {"sed_factor",0,{{-1}},NPY_FLOAT},
  {"wi",1,{{3}},NPY_FLOAT},
  {"qskr",0,{{-1}},NPY_FLOAT},
  {"g",0,{{-1}},NPY_FLOAT},
  {"diametro",1,{{3}},NPY_FLOAT},
  {"qlin_sed",0,{{-1}},NPY_FLOAT},
  {"ero",1,{{3}},NPY_FLOAT},
  {"erot",1,{{3}},NPY_FLOAT},
  {"dep",1,{{3}},NPY_FLOAT},
  {"dept",1,{{3}},NPY_FLOAT},
  {"volero",1,{{-1}},NPY_FLOAT},
  {"voldepo",1,{{-1}},NPY_FLOAT},
  {"vs",2,{{-1,-1}},NPY_FLOAT},
  {"vd",2,{{-1,-1}},NPY_FLOAT},
  {"vsc",2,{{-1,-1}},NPY_FLOAT},
  {"vdc",2,{{-1,-1}},NPY_FLOAT},
  {"krus",2,{{-1,-1}},NPY_FLOAT},
  {"crus",2,{{-1,-1}},NPY_FLOAT},
  {"prus",2,{{-1,-1}},NPY_FLOAT},
  {"parliac",2,{{-1,-1}},NPY_FLOAT},
  {"sl_gullienogullie",0,{{-1}},NPY_INT},
  {"sl_fs",0,{{-1}},NPY_FLOAT},
  {"sl_riskvector",2,{{-1,-1}},NPY_FLOAT},
  {"sl_slideocurrence",2,{{-1,-1}},NPY_FLOAT},
  {"sl_slideacumulate",2,{{-1,-1}},NPY_INT},
  {"sl_slidencelltime",1,{{-1}},NPY_INT},
  {"sl_zcrit",2,{{-1,-1}},NPY_FLOAT},
  {"sl_zmin",2,{{-1,-1}},NPY_FLOAT},
  {"sl_zmax",2,{{-1,-1}},NPY_FLOAT},
  {"sl_bo",2,{{-1,-1}},NPY_FLOAT},
  {"sl_zs",2,{{-1,-1}},NPY_FLOAT},
  {"sl_gammaw",0,{{-1}},NPY_FLOAT},
  {"sl_gammas",2,{{-1,-1}},NPY_FLOAT},
  {"sl_cohesion",2,{{-1,-1}},NPY_FLOAT},
  {"sl_frictionangle",2,{{-1,-1}},NPY_FLOAT},
  {"sl_radslope",2,{{-1,-1}},NPY_FLOAT},
  {"flood_q",2,{{-1,-1}},NPY_FLOAT},
  {"flood_qsed",2,{{-1,-1}},NPY_FLOAT},
  {"flood_h",2,{{-1,-1}},NPY_FLOAT},
  {"flood_flood",2,{{-1,-1}},NPY_INT},
  {"flood_speed",2,{{-1,-1}},NPY_FLOAT},
  {"flood_ufr",2,{{-1,-1}},NPY_FLOAT},
  {"flood_rdf",0,{{-1}},NPY_FLOAT},
  {"flood_cr",2,{{-1,-1}},NPY_FLOAT},
  {"flood_eval",2,{{-1,-1}},NPY_INT},
  {"flood_area",0,{{-1}},NPY_FLOAT},
  {"flood_diff",0,{{-1}},NPY_FLOAT},
  {"flood_sec_tam",0,{{-1}},NPY_FLOAT},
  {"flood_av",0,{{-1}},NPY_FLOAT},
  {"flood_w",2,{{-1,-1}},NPY_FLOAT},
  {"flood_d50",2,{{-1,-1}},NPY_FLOAT},
  {"flood_aquien",2,{{-1,-1}},NPY_INT},
  {"flood_hand",2,{{-1,-1}},NPY_FLOAT},
  {"flood_loc_hand",2,{{-1,-1}},NPY_FLOAT},
  {"flood_sections",2,{{-1,-1}},NPY_FLOAT},
  {"flood_sec_cells",2,{{-1,-1}},NPY_FLOAT},
  {"flood_cmax",0,{{-1}},NPY_FLOAT},
  {"flood_slope",2,{{-1,-1}},NPY_FLOAT},
  {"flood_dw",0,{{-1}},NPY_FLOAT},
  {"flood_dsed",0,{{-1}},NPY_FLOAT},
  {"flood_umbral",0,{{-1}},NPY_FLOAT},
  {"flood_max_iter",0,{{-1}},NPY_INT},
  {"flood_step",0,{{-1}},NPY_FLOAT},
  {"flood_hmax",0,{{-1}},NPY_FLOAT},
  {"flood_profundidad",2,{{-1,-1}},NPY_FLOAT},
  {"shia_v1",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_shia_v1,doc_f2py_rout_models_models_shia_v1},
  {"read_float_basin",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_read_float_basin,doc_f2py_rout_models_models_read_float_basin},
  {"read_float_basin_ncol",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_read_float_basin_ncol,doc_f2py_rout_models_models_read_float_basin_ncol},
  {"read_int_basin",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_read_int_basin,doc_f2py_rout_models_models_read_int_basin},
  {"write_float_basin",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_write_float_basin,doc_f2py_rout_models_models_write_float_basin},
  {"write_int_basin",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_write_int_basin,doc_f2py_rout_models_models_write_int_basin},
  {"rain_read_ascii_table",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_rain_read_ascii_table,doc_f2py_rout_models_models_rain_read_ascii_table},
  {"rain_read_ascii_table_separate",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_rain_read_ascii_table_separate,doc_f2py_rout_models_models_rain_read_ascii_table_separate},
  {"rain_pre_mit",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_rain_pre_mit,doc_f2py_rout_models_models_rain_pre_mit},
  {"rain_mit",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_rain_mit,doc_f2py_rout_models_models_rain_mit},
  {"rain_idw",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_rain_idw,doc_f2py_rout_models_models_rain_idw},
  {"calc_speed",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_calc_speed,doc_f2py_rout_models_models_calc_speed},
  {"sed_allocate",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_sed_allocate,doc_f2py_rout_models_models_sed_allocate},
  {"sed_hillslope",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_sed_hillslope,doc_f2py_rout_models_models_sed_hillslope},
  {"sed_channel",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_sed_channel,doc_f2py_rout_models_models_sed_channel},
  {"slide_allocate",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_slide_allocate,doc_f2py_rout_models_models_slide_allocate},
  {"slide_ocurrence",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_slide_ocurrence,doc_f2py_rout_models_models_slide_ocurrence},
  {"slide_hill2gullie",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_slide_hill2gullie,doc_f2py_rout_models_models_slide_hill2gullie},
  {"flood_allocate",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_flood_allocate,doc_f2py_rout_models_models_flood_allocate},
  {"flood_params",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_flood_params,doc_f2py_rout_models_models_flood_params},
  {"flood_find_hdiff",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_flood_find_hdiff,doc_f2py_rout_models_models_flood_find_hdiff},
  {"flood_debris_flow",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_flood_debris_flow,doc_f2py_rout_models_models_flood_debris_flow},
  {"flood_debris_flow2",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_flood_debris_flow2,doc_f2py_rout_models_models_flood_debris_flow2},
  {"basin_subbasin_map2subbasin",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_basin_subbasin_map2subbasin,doc_f2py_rout_models_models_basin_subbasin_map2subbasin},
  {"qsortc",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_qsortc,doc_f2py_rout_models_models_qsortc},
  {"partition",-1,{{-1}},0,NULL,(void *)f2py_rout_models_models_partition,doc_f2py_rout_models_models_partition},
  {NULL}
};

static void f2py_setup_models(char *xll,char *yll,char *nodata,char *dx,char *dxp,char *ncols,char *nrows,char *nceldas,char *verbose,void (*idevento)(int*,int*,void(*)(char*,int*),int*),void (*posevento)(int*,int*,void(*)(char*,int*),int*),void (*posconv)(int*,int*,void(*)(char*,int*),int*),void (*posstra)(int*,int*,void(*)(char*,int*),int*),char *rute_speed,char *rute_storage,void (*drena)(int*,int*,void(*)(char*,int*),int*),void (*unit_type)(int*,int*,void(*)(char*,int*),int*),void (*hill_long)(int*,int*,void(*)(char*,int*),int*),void (*hill_slope)(int*,int*,void(*)(char*,int*),int*),void (*stream_long)(int*,int*,void(*)(char*,int*),int*),void (*stream_slope)(int*,int*,void(*)(char*,int*),int*),void (*stream_width)(int*,int*,void(*)(char*,int*),int*),void (*elem_area)(int*,int*,void(*)(char*,int*),int*),void (*v_coef)(int*,int*,void(*)(char*,int*),int*),void (*v_exp)(int*,int*,void(*)(char*,int*),int*),void (*h_coef)(int*,int*,void(*)(char*,int*),int*),void (*h_exp)(int*,int*,void(*)(char*,int*),int*),void (*max_capilar)(int*,int*,void(*)(char*,int*),int*),void (*max_gravita)(int*,int*,void(*)(char*,int*),int*),void (*max_aquifer)(int*,int*,void(*)(char*,int*),int*),void (*retorned)(int*,int*,void(*)(char*,int*),int*),void (*evpserie)(int*,int*,void(*)(char*,int*),int*),char *retorno_gr,char *retorno_aq,char *dt,char *rain_first_point,char *sim_sediments,char *sim_slides,char *sim_floods,char *save_storage,char *save_speed,char *save_retorno,char *save_vfluxes,char *save_rc,char *show_storage,char *show_speed,char *show_mean_speed,char *show_mean_retorno,char *show_area,char *separate_fluxes,char *separate_rain,char *speed_type,void (*control)(int*,int*,void(*)(char*,int*),int*),void (*control_h)(int*,int*,void(*)(char*,int*),int*),void (*guarda_cond)(int*,int*,void(*)(char*,int*),int*),void (*guarda_vfluxes)(int*,int*,void(*)(char*,int*),int*),char *calc_niter,void (*storage)(int*,int*,void(*)(char*,int*),int*),char *storage_constant,void (*speed_map)(int*,int*,void(*)(char*,int*),int*),void (*mean_rain)(int*,int*,void(*)(char*,int*),int*),void (*acum_rain)(int*,int*,void(*)(char*,int*),int*),void (*fluxes)(int*,int*,void(*)(char*,int*),int*),void (*storage_conv)(int*,int*,void(*)(char*,int*),int*),void (*storage_stra)(int*,int*,void(*)(char*,int*),int*),void (*mean_storage)(int*,int*,void(*)(char*,int*),int*),void (*mean_speed)(int*,int*,void(*)(char*,int*),int*),void (*mean_retorno)(int*,int*,void(*)(char*,int*),int*),void (*mean_vfluxes)(int*,int*,void(*)(char*,int*),int*),void (*vfluxes)(int*,int*,void(*)(char*,int*),int*),void (*rc_coef)(int*,int*,void(*)(char*,int*),int*),char *sed_factor,char *wi,char *qskr,char *g,char *diametro,char *qlin_sed,char *ero,char *erot,char *dep,char *dept,void (*volero)(int*,int*,void(*)(char*,int*),int*),void (*voldepo)(int*,int*,void(*)(char*,int*),int*),void (*vs)(int*,int*,void(*)(char*,int*),int*),void (*vd)(int*,int*,void(*)(char*,int*),int*),void (*vsc)(int*,int*,void(*)(char*,int*),int*),void (*vdc)(int*,int*,void(*)(char*,int*),int*),void (*krus)(int*,int*,void(*)(char*,int*),int*),void (*crus)(int*,int*,void(*)(char*,int*),int*),void (*prus)(int*,int*,void(*)(char*,int*),int*),void (*parliac)(int*,int*,void(*)(char*,int*),int*),char *sl_gullienogullie,char *sl_fs,void (*sl_riskvector)(int*,int*,void(*)(char*,int*),int*),void (*sl_slideocurrence)(int*,int*,void(*)(char*,int*),int*),void (*sl_slideacumulate)(int*,int*,void(*)(char*,int*),int*),void (*sl_slidencelltime)(int*,int*,void(*)(char*,int*),int*),void (*sl_zcrit)(int*,int*,void(*)(char*,int*),int*),void (*sl_zmin)(int*,int*,void(*)(char*,int*),int*),void (*sl_zmax)(int*,int*,void(*)(char*,int*),int*),void (*sl_bo)(int*,int*,void(*)(char*,int*),int*),void (*sl_zs)(int*,int*,void(*)(char*,int*),int*),char *sl_gammaw,void (*sl_gammas)(int*,int*,void(*)(char*,int*),int*),void (*sl_cohesion)(int*,int*,void(*)(char*,int*),int*),void (*sl_frictionangle)(int*,int*,void(*)(char*,int*),int*),void (*sl_radslope)(int*,int*,void(*)(char*,int*),int*),void (*flood_q)(int*,int*,void(*)(char*,int*),int*),void (*flood_qsed)(int*,int*,void(*)(char*,int*),int*),void (*flood_h)(int*,int*,void(*)(char*,int*),int*),void (*flood_flood)(int*,int*,void(*)(char*,int*),int*),void (*flood_speed)(int*,int*,void(*)(char*,int*),int*),void (*flood_ufr)(int*,int*,void(*)(char*,int*),int*),char *flood_rdf,void (*flood_cr)(int*,int*,void(*)(char*,int*),int*),void (*flood_eval)(int*,int*,void(*)(char*,int*),int*),char *flood_area,char *flood_diff,char *flood_sec_tam,char *flood_av,void (*flood_w)(int*,int*,void(*)(char*,int*),int*),void (*flood_d50)(int*,int*,void(*)(char*,int*),int*),void (*flood_aquien)(int*,int*,void(*)(char*,int*),int*),void (*flood_hand)(int*,int*,void(*)(char*,int*),int*),void (*flood_loc_hand)(int*,int*,void(*)(char*,int*),int*),void (*flood_sections)(int*,int*,void(*)(char*,int*),int*),void (*flood_sec_cells)(int*,int*,void(*)(char*,int*),int*),char *flood_cmax,void (*flood_slope)(int*,int*,void(*)(char*,int*),int*),char *flood_dw,char *flood_dsed,char *flood_umbral,char *flood_max_iter,char *flood_step,char *flood_hmax,void (*flood_profundidad)(int*,int*,void(*)(char*,int*),int*),char *shia_v1,char *read_float_basin,char *read_float_basin_ncol,char *read_int_basin,char *write_float_basin,char *write_int_basin,char *rain_read_ascii_table,char *rain_read_ascii_table_separate,char *rain_pre_mit,char *rain_mit,char *rain_idw,char *calc_speed,char *sed_allocate,char *sed_hillslope,char *sed_channel,char *slide_allocate,char *slide_ocurrence,char *slide_hill2gullie,char *flood_allocate,char *flood_params,char *flood_find_hdiff,char *flood_debris_flow,char *flood_debris_flow2,char *basin_subbasin_map2subbasin,char *qsortc,char *partition) {
  int i_f2py=0;
  f2py_models_def[i_f2py++].data = xll;
  f2py_models_def[i_f2py++].data = yll;
  f2py_models_def[i_f2py++].data = nodata;
  f2py_models_def[i_f2py++].data = dx;
  f2py_models_def[i_f2py++].data = dxp;
  f2py_models_def[i_f2py++].data = ncols;
  f2py_models_def[i_f2py++].data = nrows;
  f2py_models_def[i_f2py++].data = nceldas;
  f2py_models_def[i_f2py++].data = verbose;
  f2py_models_def[i_f2py++].func = idevento;
  f2py_models_def[i_f2py++].func = posevento;
  f2py_models_def[i_f2py++].func = posconv;
  f2py_models_def[i_f2py++].func = posstra;
  f2py_models_def[i_f2py++].data = rute_speed;
  f2py_models_def[i_f2py++].data = rute_storage;
  f2py_models_def[i_f2py++].func = drena;
  f2py_models_def[i_f2py++].func = unit_type;
  f2py_models_def[i_f2py++].func = hill_long;
  f2py_models_def[i_f2py++].func = hill_slope;
  f2py_models_def[i_f2py++].func = stream_long;
  f2py_models_def[i_f2py++].func = stream_slope;
  f2py_models_def[i_f2py++].func = stream_width;
  f2py_models_def[i_f2py++].func = elem_area;
  f2py_models_def[i_f2py++].func = v_coef;
  f2py_models_def[i_f2py++].func = v_exp;
  f2py_models_def[i_f2py++].func = h_coef;
  f2py_models_def[i_f2py++].func = h_exp;
  f2py_models_def[i_f2py++].func = max_capilar;
  f2py_models_def[i_f2py++].func = max_gravita;
  f2py_models_def[i_f2py++].func = max_aquifer;
  f2py_models_def[i_f2py++].func = retorned;
  f2py_models_def[i_f2py++].func = evpserie;
  f2py_models_def[i_f2py++].data = retorno_gr;
  f2py_models_def[i_f2py++].data = retorno_aq;
  f2py_models_def[i_f2py++].data = dt;
  f2py_models_def[i_f2py++].data = rain_first_point;
  f2py_models_def[i_f2py++].data = sim_sediments;
  f2py_models_def[i_f2py++].data = sim_slides;
  f2py_models_def[i_f2py++].data = sim_floods;
  f2py_models_def[i_f2py++].data = save_storage;
  f2py_models_def[i_f2py++].data = save_speed;
  f2py_models_def[i_f2py++].data = save_retorno;
  f2py_models_def[i_f2py++].data = save_vfluxes;
  f2py_models_def[i_f2py++].data = save_rc;
  f2py_models_def[i_f2py++].data = show_storage;
  f2py_models_def[i_f2py++].data = show_speed;
  f2py_models_def[i_f2py++].data = show_mean_speed;
  f2py_models_def[i_f2py++].data = show_mean_retorno;
  f2py_models_def[i_f2py++].data = show_area;
  f2py_models_def[i_f2py++].data = separate_fluxes;
  f2py_models_def[i_f2py++].data = separate_rain;
  f2py_models_def[i_f2py++].data = speed_type;
  f2py_models_def[i_f2py++].func = control;
  f2py_models_def[i_f2py++].func = control_h;
  f2py_models_def[i_f2py++].func = guarda_cond;
  f2py_models_def[i_f2py++].func = guarda_vfluxes;
  f2py_models_def[i_f2py++].data = calc_niter;
  f2py_models_def[i_f2py++].func = storage;
  f2py_models_def[i_f2py++].data = storage_constant;
  f2py_models_def[i_f2py++].func = speed_map;
  f2py_models_def[i_f2py++].func = mean_rain;
  f2py_models_def[i_f2py++].func = acum_rain;
  f2py_models_def[i_f2py++].func = fluxes;
  f2py_models_def[i_f2py++].func = storage_conv;
  f2py_models_def[i_f2py++].func = storage_stra;
  f2py_models_def[i_f2py++].func = mean_storage;
  f2py_models_def[i_f2py++].func = mean_speed;
  f2py_models_def[i_f2py++].func = mean_retorno;
  f2py_models_def[i_f2py++].func = mean_vfluxes;
  f2py_models_def[i_f2py++].func = vfluxes;
  f2py_models_def[i_f2py++].func = rc_coef;
  f2py_models_def[i_f2py++].data = sed_factor;
  f2py_models_def[i_f2py++].data = wi;
  f2py_models_def[i_f2py++].data = qskr;
  f2py_models_def[i_f2py++].data = g;
  f2py_models_def[i_f2py++].data = diametro;
  f2py_models_def[i_f2py++].data = qlin_sed;
  f2py_models_def[i_f2py++].data = ero;
  f2py_models_def[i_f2py++].data = erot;
  f2py_models_def[i_f2py++].data = dep;
  f2py_models_def[i_f2py++].data = dept;
  f2py_models_def[i_f2py++].func = volero;
  f2py_models_def[i_f2py++].func = voldepo;
  f2py_models_def[i_f2py++].func = vs;
  f2py_models_def[i_f2py++].func = vd;
  f2py_models_def[i_f2py++].func = vsc;
  f2py_models_def[i_f2py++].func = vdc;
  f2py_models_def[i_f2py++].func = krus;
  f2py_models_def[i_f2py++].func = crus;
  f2py_models_def[i_f2py++].func = prus;
  f2py_models_def[i_f2py++].func = parliac;
  f2py_models_def[i_f2py++].data = sl_gullienogullie;
  f2py_models_def[i_f2py++].data = sl_fs;
  f2py_models_def[i_f2py++].func = sl_riskvector;
  f2py_models_def[i_f2py++].func = sl_slideocurrence;
  f2py_models_def[i_f2py++].func = sl_slideacumulate;
  f2py_models_def[i_f2py++].func = sl_slidencelltime;
  f2py_models_def[i_f2py++].func = sl_zcrit;
  f2py_models_def[i_f2py++].func = sl_zmin;
  f2py_models_def[i_f2py++].func = sl_zmax;
  f2py_models_def[i_f2py++].func = sl_bo;
  f2py_models_def[i_f2py++].func = sl_zs;
  f2py_models_def[i_f2py++].data = sl_gammaw;
  f2py_models_def[i_f2py++].func = sl_gammas;
  f2py_models_def[i_f2py++].func = sl_cohesion;
  f2py_models_def[i_f2py++].func = sl_frictionangle;
  f2py_models_def[i_f2py++].func = sl_radslope;
  f2py_models_def[i_f2py++].func = flood_q;
  f2py_models_def[i_f2py++].func = flood_qsed;
  f2py_models_def[i_f2py++].func = flood_h;
  f2py_models_def[i_f2py++].func = flood_flood;
  f2py_models_def[i_f2py++].func = flood_speed;
  f2py_models_def[i_f2py++].func = flood_ufr;
  f2py_models_def[i_f2py++].data = flood_rdf;
  f2py_models_def[i_f2py++].func = flood_cr;
  f2py_models_def[i_f2py++].func = flood_eval;
  f2py_models_def[i_f2py++].data = flood_area;
  f2py_models_def[i_f2py++].data = flood_diff;
  f2py_models_def[i_f2py++].data = flood_sec_tam;
  f2py_models_def[i_f2py++].data = flood_av;
  f2py_models_def[i_f2py++].func = flood_w;
  f2py_models_def[i_f2py++].func = flood_d50;
  f2py_models_def[i_f2py++].func = flood_aquien;
  f2py_models_def[i_f2py++].func = flood_hand;
  f2py_models_def[i_f2py++].func = flood_loc_hand;
  f2py_models_def[i_f2py++].func = flood_sections;
  f2py_models_def[i_f2py++].func = flood_sec_cells;
  f2py_models_def[i_f2py++].data = flood_cmax;
  f2py_models_def[i_f2py++].func = flood_slope;
  f2py_models_def[i_f2py++].data = flood_dw;
  f2py_models_def[i_f2py++].data = flood_dsed;
  f2py_models_def[i_f2py++].data = flood_umbral;
  f2py_models_def[i_f2py++].data = flood_max_iter;
  f2py_models_def[i_f2py++].data = flood_step;
  f2py_models_def[i_f2py++].data = flood_hmax;
  f2py_models_def[i_f2py++].func = flood_profundidad;
  f2py_models_def[i_f2py++].data = shia_v1;
  f2py_models_def[i_f2py++].data = read_float_basin;
  f2py_models_def[i_f2py++].data = read_float_basin_ncol;
  f2py_models_def[i_f2py++].data = read_int_basin;
  f2py_models_def[i_f2py++].data = write_float_basin;
  f2py_models_def[i_f2py++].data = write_int_basin;
  f2py_models_def[i_f2py++].data = rain_read_ascii_table;
  f2py_models_def[i_f2py++].data = rain_read_ascii_table_separate;
  f2py_models_def[i_f2py++].data = rain_pre_mit;
  f2py_models_def[i_f2py++].data = rain_mit;
  f2py_models_def[i_f2py++].data = rain_idw;
  f2py_models_def[i_f2py++].data = calc_speed;
  f2py_models_def[i_f2py++].data = sed_allocate;
  f2py_models_def[i_f2py++].data = sed_hillslope;
  f2py_models_def[i_f2py++].data = sed_channel;
  f2py_models_def[i_f2py++].data = slide_allocate;
  f2py_models_def[i_f2py++].data = slide_ocurrence;
  f2py_models_def[i_f2py++].data = slide_hill2gullie;
  f2py_models_def[i_f2py++].data = flood_allocate;
  f2py_models_def[i_f2py++].data = flood_params;
  f2py_models_def[i_f2py++].data = flood_find_hdiff;
  f2py_models_def[i_f2py++].data = flood_debris_flow;
  f2py_models_def[i_f2py++].data = flood_debris_flow2;
  f2py_models_def[i_f2py++].data = basin_subbasin_map2subbasin;
  f2py_models_def[i_f2py++].data = qsortc;
  f2py_models_def[i_f2py++].data = partition;
}
extern void F_FUNC(f2pyinitmodels,F2PYINITMODELS)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),void (*)(int*,int*,void(*)(char*,int*),int*),char*,void (*)(int*,int*,void(*)(char*,int*),int*),char*,char*,char*,char*,char*,char*,void (*)(int*,int*,void(*)(char*,int*),int*),char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_models(void) {
  F_FUNC(f2pyinitmodels,F2PYINITMODELS)(f2py_setup_models);
}

/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {

/*eof routine_defs*/
  {NULL}
};

static PyMethodDef f2py_module_methods[] = {

  {NULL,NULL}
};

#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef moduledef = {
  PyModuleDef_HEAD_INIT,
  "models",
  NULL,
  -1,
  f2py_module_methods,
  NULL,
  NULL,
  NULL,
  NULL
};
#endif

#if PY_VERSION_HEX >= 0x03000000
#define RETVAL m
PyMODINIT_FUNC PyInit_models(void) {
#else
#define RETVAL
PyMODINIT_FUNC initmodels(void) {
#endif
  int i;
  PyObject *m,*d, *s, *tmp;
#if PY_VERSION_HEX >= 0x03000000
  m = models_module = PyModule_Create(&moduledef);
#else
  m = models_module = Py_InitModule("models", f2py_module_methods);
#endif
  Py_TYPE(&PyFortran_Type) = &PyType_Type;
  import_array();
  if (PyErr_Occurred())
    {PyErr_SetString(PyExc_ImportError, "can't initialize module models (failed to import numpy)"); return RETVAL;}
  d = PyModule_GetDict(m);
  s = PyString_FromString("$Revision: $");
  PyDict_SetItemString(d, "__version__", s);
  Py_DECREF(s);
#if PY_VERSION_HEX >= 0x03000000
  s = PyUnicode_FromString(
#else
  s = PyString_FromString(
#endif
    "This module 'models' is auto-generated with f2py (version:2).\nFunctions:\n"
"Fortran 90/95 modules:\n""  models --- xll,yll,nodata,dx,dxp,ncols,nrows,nceldas,verbose,idevento,posevento,posconv,posstra,rute_speed,rute_storage,drena,unit_type,hill_long,hill_slope,stream_long,stream_slope,stream_width,elem_area,v_coef,v_exp,h_coef,h_exp,max_capilar,max_gravita,max_aquifer,retorned,evpserie,retorno_gr,retorno_aq,dt,rain_first_point,sim_sediments,sim_slides,sim_floods,save_storage,save_speed,save_retorno,save_vfluxes,save_rc,show_storage,show_speed,show_mean_speed,show_mean_retorno,show_area,separate_fluxes,separate_rain,speed_type,control,control_h,guarda_cond,guarda_vfluxes,calc_niter,storage,storage_constant,speed_map,mean_rain,acum_rain,fluxes,storage_conv,storage_stra,mean_storage,mean_speed,mean_retorno,mean_vfluxes,vfluxes,rc_coef,sed_factor,wi,qskr,g,diametro,qlin_sed,ero,erot,dep,dept,volero,voldepo,vs,vd,vsc,vdc,krus,crus,prus,parliac,sl_gullienogullie,sl_fs,sl_riskvector,sl_slideocurrence,sl_slideacumulate,sl_slidencelltime,sl_zcrit,sl_zmin,sl_zmax,sl_bo,sl_zs,sl_gammaw,sl_gammas,sl_cohesion,sl_frictionangle,sl_radslope,flood_q,flood_qsed,flood_h,flood_flood,flood_speed,flood_ufr,flood_rdf,flood_cr,flood_eval,flood_area,flood_diff,flood_sec_tam,flood_av,flood_w,flood_d50,flood_aquien,flood_hand,flood_loc_hand,flood_sections,flood_sec_cells,flood_cmax,flood_slope,flood_dw,flood_dsed,flood_umbral,flood_max_iter,flood_step,flood_hmax,flood_profundidad,shia_v1(),read_float_basin(),read_float_basin_ncol(),read_int_basin(),write_float_basin(),write_int_basin(),rain_read_ascii_table(),rain_read_ascii_table_separate(),rain_pre_mit(),rain_mit(),rain_idw(),calc_speed(),sed_allocate(),sed_hillslope(),sed_channel(),slide_allocate(),slide_ocurrence(),slide_hill2gullie(),flood_allocate(),flood_params(),flood_find_hdiff(),flood_debris_flow(),flood_debris_flow2(),basin_subbasin_map2subbasin(),qsortc(),partition()"".");
  PyDict_SetItemString(d, "__doc__", s);
  Py_DECREF(s);
  models_error = PyErr_NewException ("models.error", NULL, NULL);
  /*
   * Store the error object inside the dict, so that it could get deallocated.
   * (in practice, this is a module, so it likely will not and cannot.)
   */
  PyDict_SetItemString(d, "_models_error", models_error);
  Py_DECREF(models_error);
  for(i=0;f2py_routine_defs[i].name!=NULL;i++) {
    tmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
    PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
    Py_DECREF(tmp);
  }


























/*eof initf2pywraphooks*/
  PyDict_SetItemString(d, "models", PyFortranObject_New(f2py_models_def,f2py_init_models));
/*eof initf90modhooks*/

/*eof initcommonhooks*/


#ifdef F2PY_REPORT_ATEXIT
  if (! PyErr_Occurred())
    on_exit(f2py_report_on_exit,(void*)"models");
#endif
  return RETVAL;
}
#ifdef __cplusplus
}
#endif
